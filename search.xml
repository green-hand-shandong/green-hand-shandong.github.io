<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>455.分发饼干</title>
    <url>/2020/07/25/LC-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>问题分割成子问题。套娃。</p>
<p>贪心原则由内向外。</p>
<p>不会直接从整体考虑问题，而是想要达到局部最优</p>
<p>只有内部的子问题求得最优解，才能继续解决包含该子问题的下一个子问题，所以前一个子问题的最优解会是下一个子问题最优解的一部分</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>贪心选择的意思是对于所求问题的整体最优解可以通过一系列的局部最优选择求得。而必须注意的是，贪心选择必须具备无后效性，也就是某个状态不会影响之前求得的局部最优解。</p>
<p>省去了寻找全局最优解很多不必要的穷举操作，由于贪心算法问题并没有固定的贪心策略，所以<strong>唯一的难点就是找到带求解问题的贪心策略</strong>，<strong>但毕竟熟能生巧嘛</strong>，算法的基本思想总是固定不变的。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ol>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a>455. 分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<ul>
<li>你可以假设胃口值为正。</li>
<li>一个小朋友最多只能拥有一块饼干</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/R4or34uBPGiakKG6RgQicflVObq1NmkQcmnHuLJJpggF1Enc8XgtsHaUN15zOTmCyHpO3lE3DgN6D1wrMhLDomLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这道题的思路主要包括两个点：</p>
<ol>
<li>尽量先满足胃口值小的孩子，因为这样的孩子容易满足。</li>
<li>进行条件1时，尽可能选用尺寸小的，这样大尺寸饼干可以用来满足胃口值大的孩子。</li>
</ol>
<p>这道题的贪心思想非常明显，就是要尽可能地满足更多的孩子，而胃口值小的孩子是容易满足的，反之胃口值大的孩子很难满足，所以在抉择上尽可能满足前者、饿着后者。</p>
<p>这个思想可以类比于赛马，我们假设赢或者平作为满足条件。如果A的3赢了B的1，那么剩下两匹的结果可能就是一平一负或者两负，那么此时至多才是1满足；而如果A的马和B的马都按照顺序比，则可以达到3平，那么此时可以达到3满足。</p>
<p>所以综上可以得到解题思路，首先需要将胃口值和饼干尺寸由小至大排序。设定一个计数器child，用来记得到满足的孩子个数，再维护一个饼干指针cookies。如果饼干尺寸可以满足孩子胃口值，即g[child]&lt;=s[cookies]，就将child、cookies分别加一(向后移动一位)，否则只将cookies向后移动一位。因为孩子的胃口值是由小到大的，若不满足当前的胃口值更不会满足之后的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(g,s)</span>:</span></span><br><span class="line">    g.sort()//排序</span><br><span class="line">    S.sort()</span><br><span class="line">    child = <span class="number">0</span>;//指针</span><br><span class="line">    cookies = <span class="number">0</span>；</span><br><span class="line">    <span class="keyword">while</span> child &lt; len(g) <span class="keyword">and</span> cookies &lt;len(s):</span><br><span class="line">        <span class="keyword">if</span> g[child] &lt; s[cookies]:</span><br><span class="line">            child += <span class="number">1</span>;</span><br><span class="line">        cookies += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> child</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++学习</title>
    <url>/2020/07/25/c-cpp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="c-堆区"><a href="#c-堆区" class="headerlink" title="c++ 堆区"></a>c++ 堆区</h2><p><code>p = new int(3);//初值 —— delete p //释放变量</code></p>
<p><code>p = new int[3];//申请数组  —— delete []p// 释放数组</code></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Max</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> x,<span class="built_in">std</span>::<span class="built_in">string</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">T</span> <span class="title">Max</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">		<span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>PL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode 配置记录</title>
    <url>/2020/07/25/VScode%E5%B0%8F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><h3 id="配置工具和语言"><a href="#配置工具和语言" class="headerlink" title="配置工具和语言"></a>配置工具和语言</h3><p>配置Git路径：<a href="https://juejin.im/post/5e5de67ee51d452726152152" target="_blank" rel="noopener">https://juejin.im/post/5e5de67ee51d452726152152</a></p>
<p>配置C/C++：<a href="https://www.zhihu.com/question/30315894" target="_blank" rel="noopener">https://www.zhihu.com/question/30315894</a></p>
<p>配置py：<a href="https://zhuanlan.zhihu.com/p/66157046" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66157046</a></p>
<p>快捷键：<a href="https://lzw.me/a/vscode-visual-studio-code-shortcut.html" target="_blank" rel="noopener">https://lzw.me/a/vscode-visual-studio-code-shortcut.html</a></p>
<h3 id="IDE-amp-编辑器"><a href="#IDE-amp-编辑器" class="headerlink" title="IDE &amp; 编辑器"></a>IDE &amp; 编辑器</h3><ul>
<li><strong>IDE</strong>（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</li>
<li><strong>编辑器</strong>：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</li>
</ul>
<p>VS Code 的定位是<strong>编辑器</strong>，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>JS实现的VScode</li>
<li>自带 JavaScript、TypeScript 和 Node.js 的支持</li>
<li>插件功能强大</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>需要积累<a href="https://zhuanlan.zhihu.com/p/62913725" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62913725</a></p>
<p>命令行<code>Ctrl+Shift+P</code>，修改设置</p>
<ul>
<li>‘’字体’’、大小写“transfrom”、</li>
<li>windows命令行“code | code path/filename”快速启动</li>
<li>ctrl + \  打开多个编辑器窗口</li>
<li>shift + F12 某函数在哪些地方被调用了</li>
<li>三击  / 单击行号  选中当前行</li>
</ul>
<p>重构</p>
<ul>
<li><p>函数、变量名，</p>
<p>   光标放在上面而后 F2 ，出现这个函数名的地方都会被修改</p>
</li>
<li><p>方法、</p>
<p>   选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。</p>
</li>
</ul>
<p>查找</p>
<p><img src="https://pic1.zhimg.com/80/v2-cbe55b8fb428d65c5c720f08cf25496b_720w.jpg" alt="img"></p>
<ul>
<li>全局查找： Ctrl + Shift +F</li>
</ul>
<p>放缩</p>
<ul>
<li>ctrl   + / -</li>
<li>回复默认：命令面板输入<code>重置缩放</code>（英文是<code>reset zoom</code>）</li>
</ul>
<p>创建文件</p>
<ul>
<li><p>多层文件夹：如果直接输入<code>aa/bb/cc</code></p>
</li>
<li><p>.vscode 根文件夹</p>
<p>   只对当前项目有用</p>
</li>
</ul>
<p>格式化</p>
<ul>
<li><p>根目录添加，文件<code>.prettierrc</code></p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"printWidth"</span>: <span class="number">150</span>,</span><br><span class="line">  <span class="string">"tabWidth"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="string">"semi"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"trailingComma"</span>: <span class="string">"es5"</span>,</span><br><span class="line">  <span class="string">"tslintIntegration"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"insertSpaceBeforeFunctionParenthesis"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令面板 -&gt; Format document / selection</p>
</li>
</ul>
<p>// TODO:</p>
<ul>
<li><pre><code class="text">//TODO:这里有个bug，我一会儿再收拾你
//FIXME:我也不知道为啥， but it works only that way.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。</span><br><span class="line"></span><br><span class="line">### 文件传输：sftp</span><br><span class="line"></span><br><span class="line">如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装&#96;sftp&#96;这个插件，很好用。在公司会经常用到。</span><br><span class="line"></span><br><span class="line">步骤如下：</span><br><span class="line"></span><br><span class="line">（1）安装插件&#96;sftp&#96;。</span><br><span class="line"></span><br><span class="line">（2）配置 &#96;sftp.json&#96;文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入&#96;sftp:config&#96;，回车，当前工程的&#96;.vscode&#96;文件夹下就会自动生成一个&#96;sftp.json&#96;文件，我们需要在这个文件里配置的内容可以是：</span><br><span class="line"></span><br><span class="line">- &#96;host&#96;：服务器的 IP 地址</span><br><span class="line">- &#96;username&#96;：用户名</span><br><span class="line">- &#96;privateKeyPath&#96;：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）</span><br><span class="line">- &#96;remotePath&#96;：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录</span><br><span class="line">- &#96;ignore&#96;：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号</span><br><span class="line"></span><br><span class="line">举例如下：(注意，其中的注释需要去掉)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;host&quot;: &quot;192.168.xxx.xxx&quot;, &#x2F;&#x2F;服务器ip</span><br><span class="line">  &quot;port&quot;: 22, &#x2F;&#x2F;端口，sftp模式是22</span><br><span class="line">  &quot;username&quot;: &quot;&quot;, &#x2F;&#x2F;用户名</span><br><span class="line">  &quot;password&quot;: &quot;&quot;, &#x2F;&#x2F;密码</span><br><span class="line">  &quot;protocol&quot;: &quot;sftp&quot;, &#x2F;&#x2F;模式</span><br><span class="line">  &quot;agent&quot;: null,</span><br><span class="line">  &quot;privateKeyPath&quot;: null,</span><br><span class="line">  &quot;passphrase&quot;: null,</span><br><span class="line">  &quot;passive&quot;: false,</span><br><span class="line">  &quot;interactiveAuth&quot;: false,</span><br><span class="line">  &quot;remotePath&quot;: &quot;&#x2F;root&#x2F;node&#x2F;build&#x2F;&quot;, &#x2F;&#x2F;服务器上的文件地址</span><br><span class="line">  &quot;context&quot;: &quot;.&#x2F;server&#x2F;build&quot;, &#x2F;&#x2F;本地的文件地址</span><br><span class="line"></span><br><span class="line">  &quot;uploadOnSave&quot;: true, &#x2F;&#x2F;监听保存并上传</span><br><span class="line">  &quot;syncMode&quot;: &quot;update&quot;,</span><br><span class="line">  &quot;watcher&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F;监听外部文件</span><br><span class="line">    &quot;files&quot;: false, &#x2F;&#x2F;外部文件的绝对路径</span><br><span class="line">    &quot;autoUpload&quot;: false,</span><br><span class="line">    &quot;autoDelete&quot;: false</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &#x2F;&#x2F;忽略项</span><br><span class="line">    &quot;**&#x2F;.vscode&#x2F;**&quot;,</span><br><span class="line">    &quot;**&#x2F;.git&#x2F;**&quot;,</span><br><span class="line">    &quot;**&#x2F;.DS_Store&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>（3）在 VS Code 的当前文件里，选择「右键 -&gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 <code>host</code> 中配置的服务器 ip）。</p>
<p>我们还可以选择「右键 -&gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。</p>
<h3 id="配置云同步-undone"><a href="#配置云同步-undone" class="headerlink" title="配置云同步 undone"></a>配置云同步 undone</h3><h3 id="快速粘贴图片"><a href="#快速粘贴图片" class="headerlink" title="快速粘贴图片"></a>快速粘贴图片</h3><p>paste image插件：<a href="https://crifan.github.io/best_editor_vscode/website/plugin/common_plugins/paste_image.html" target="_blank" rel="noopener">https://crifan.github.io/best_editor_vscode/website/plugin/common_plugins/paste_image.html</a></p>
<p>paste image 快捷键被占用</p>
<p><a href="https://www.crifan.com/vscode_plugin_paste_image_shortcut_command_alt_v_not_work/" target="_blank" rel="noopener">https://www.crifan.com/vscode_plugin_paste_image_shortcut_command_alt_v_not_work/</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown + latex</title>
    <url>/2020/07/25/markdown-latex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Typora-–-LaTeX-：速查"><a href="#Typora-–-LaTeX-：速查" class="headerlink" title="Typora – LaTeX ：速查"></a>Typora – LaTeX ：速查</h1><p>[转载：]</p>
<p><a href="http://www.domuse.com/markdown-and-latex-equation-handbook.html" target="_blank" rel="noopener">http://www.domuse.com/markdown-and-latex-equation-handbook.html</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>markdown-latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Git们</title>
    <url>/2020/07/25/Git%E5%85%84%E5%BC%9F%E4%BB%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="版本管理三剑客"><a href="#版本管理三剑客" class="headerlink" title="版本管理三剑客"></a>版本管理三剑客</h2><p>Git / GitHub / GitLab</p>
<h2 id="国内的GitHub"><a href="#国内的GitHub" class="headerlink" title="国内的GitHub"></a>国内的GitHub</h2><p>Gitee</p>
<h2 id="绝佳的整理工具：Gitbook"><a href="#绝佳的整理工具：Gitbook" class="headerlink" title="绝佳的整理工具：Gitbook"></a>绝佳的整理工具：Gitbook</h2><p>Gitbook是一个命令行工具(node.js库)， 使用Github/Git创建漂亮的图书。 你可以看一些用它编写的图书的例子： 学习Javascript. 你也可以很容易的通过gitbook.io网站发布在线图书。 editor 是一个图形化的编辑工具， 提供Windows, Mac 和Linux的版本. 关注Twitter帐号 @GitBookIO. 这篇文章只是一个起步教程， 完整的文档可以在help.gitbook.io网站找到.</p>
<p>将一个repository作为一本电子书来写<br>输出格式支持–.MD、.PDF<br>并且自动生成目录结构</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://colobu.com/2014/10/09/gitbook-quickstart/" target="_blank" rel="noopener">https://colobu.com/2014/10/09/gitbook-quickstart/</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git-</tag>
      </tags>
  </entry>
  <entry>
    <title>鸢尾花-sklearn-KNN</title>
    <url>/2020/07/25/sklearn-%E9%B8%A2%E5%B0%BE%E8%8A%B1-KNN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line">iris_dataset = load_iris()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split </span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">iris_dataset[<span class="string">'data'</span>], iris_dataset[<span class="string">'target'</span>], random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier </span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line">print(<span class="string">"Test set predictions:\n &#123;&#125;"</span>.format(y_pred))</span><br><span class="line">print(<span class="string">"Test set score: &#123;:.2f&#125;"</span>.format(np.mean(y_pred == y_test)))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 配置记录</title>
    <url>/2020/07/25/hexo%E5%B0%8F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="hexo博客"><a href="#hexo博客" class="headerlink" title="hexo博客"></a>hexo博客</h2><p>地址：<a href="https://green-hand-shandong.github.io/" target="_blank" rel="noopener">https://green-hand-shandong.github.io/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">github+hexo个人网站详细教程</a></p>
<p><a href="[https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo](https://hexo.io/zh-cn/docs/#安装-Hexo)">hexo 文档</a></p>
<h3 id="hexo-主题变更"><a href="#hexo-主题变更" class="headerlink" title="hexo 主题变更"></a>hexo 主题变更</h3><p>官方主题社区<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<p>通用变更手段<a href="[https://suda-liu.github.io/2020/03/21/%E4%BB%A5NexT%E4%B8%BB%E9%A2%98%E4%B8%BA%E4%BE%8B%E8%AE%B2%E8%AE%B2%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/](https://suda-liu.github.io/2020/03/21/以NexT主题为例讲讲如何更换Hexo博客主题/)">套路</a></p>
<p>ayer：<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">https://shen-yu.gitee.io/2019/ayer/</a></p>
<p>hexo插件市场：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>当然你可能并不想所有文章都生成悬浮目录，你可以在文章顶部的配置中加一行来进行关闭：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COPY---</span><br><span class="line">no_toc: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="hexo-二次元看板-UNDONE"><a href="#hexo-二次元看板-UNDONE" class="headerlink" title="hexo 二次元看板 UNDONE"></a>hexo 二次元看板 UNDONE</h3><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a></p>
<h3 id="hexo实现在线运行代码"><a href="#hexo实现在线运行代码" class="headerlink" title="hexo实现在线运行代码"></a>hexo实现在线运行代码</h3><p><a href="[https://mlln.cn/2018/09/14/%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E5%AE%9E%E6%97%B6%E8%BF%90%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8A%9F%E8%83%BD/](https://mlln.cn/2018/09/14/给博客增加实时运行python代码的功能/)">python  在线</a></p>
<h3 id="分类、标签"><a href="#分类、标签" class="headerlink" title="分类、标签"></a>分类、标签</h3><p><a href="https://blog.yaalon.xyz/2020/06/13/Blog/Hexo新建归档、分类、标签等页面/" target="_blank" rel="noopener">https://blog.yaalon.xyz/2020/06/13/Blog/Hexo%E6%96%B0%E5%BB%BA%E5%BD%92%E6%A1%A3%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E6%A0%87%E7%AD%BE%E7%AD%89%E9%A1%B5%E9%9D%A2/</a></p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><a href="http://www.hakkin.net/2018/04/15/在hexo中使用ECharts/" target="_blank" rel="noopener">http://www.hakkin.net/2018/04/15/%E5%9C%A8hexo%E4%B8%AD%E4%BD%BF%E7%94%A8ECharts/</a></p>
<p><a href="https://kchen.cc/2016/11/05/echarts-in-hexo/" target="_blank" rel="noopener">https://kchen.cc/2016/11/05/echarts-in-hexo/</a></p>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p><a href="https://pengloo53.gitbooks.io/hexo/content/chapter2/7%20%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95.html" target="_blank" rel="noopener">https://pengloo53.gitbooks.io/hexo/content/chapter2/7%20%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95.html</a></p>
<h3 id="文档树、图-——-UNDONE"><a href="#文档树、图-——-UNDONE" class="headerlink" title="文档树、图 —— UNDONE"></a>文档树、图 —— UNDONE</h3><p>树、图、可视化</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/2020/07/25/%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>概念、特点。KMP思想(求串的next和nextval)</li>
<li>选择、判断、填空</li>
<li>5%</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>串 —— 线性  —— 一对一</p>
<ul>
<li><strong>每一个元素都是一个字符</strong></li>
<li>操作对象 —— 一组数据元素</li>
</ul>
</li>
<li><p>定义 ： 若干个字符组成的有限序列</p>
<ul>
<li>S = a0a1a2a3a4…a_(n-1)</li>
<li>a_i 是<strong>字符</strong></li>
<li>真子串 ：非空 &amp;&amp; 不为自身</li>
<li>子串定位 ：/模式匹配 /模型匹配。</li>
<li>位置 —— 子串首字符的位序</li>
<li>长度空格也计入</li>
</ul>
</li>
<li><p>顺序存储结构</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">bfFind</span><span class="params">(<span class="keyword">const</span> String &amp;s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span><span class="keyword">const</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">kmpFind</span><span class="params">(<span class="keyword">const</span> String &amp;s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> String &amp;s,<span class="keyword">int</span> *next)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">getNextVal</span><span class="params">(<span class="keyword">const</span> String &amp;s, <span class="keyword">int</span> *nextval)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	cahr* data;<span class="comment">//字符数组</span></span><br><span class="line">    	<span class="keyword">int</span> maxSzie;</span><br><span class="line">    	<span class="keyword">int</span> curLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式不方便</p>
<ul>
<li>一个节点存放一个字符 —— 存储密度 20% （1/5）</li>
<li>块链存储密度大，但是插入删除移动大量元素</li>
</ul>
</li>
<li><p>模式匹配/子串定位。主串中找目标串/模式串</p>
<ul>
<li><p>朴素</p>
<ul>
<li><p>两个指针。相等则同时遍历，不相等则<strong>回退</strong>。返回子串出现位置</p>
<ul>
<li><p>回退 —— 主串i回到 i= i-j+1。子串j回到 j=0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(S.curLength&lt;T.curLength)<span class="comment">//子串得比主串短</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;S.curLength &amp;&amp;j &lt; T.curLength)&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.data[i]==T.data[j])</span><br><span class="line">        i++,j++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = i-j+<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=T.curLength)	<span class="comment">//成功，子串能走完</span></span><br><span class="line">    <span class="keyword">return</span>(i-T.curLength);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// O(T.length) —— O(S.length * T.length)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>KMP —— Knuth教授，+两个人</p>
<ul>
<li>主串不回溯，子串回溯</li>
<li>时间复杂度O(m+n)，空间复杂度 O(T.length)</li>
<li>Si和Tj比较失配时，主串 i 不回溯，子串第 Tk 个元素（子串由j回溯到k）和 Si 比较。<ul>
<li>暗示，前 j 个字符都是匹配的。</li>
<li><strong>K</strong><ul>
<li>相等的首串/前缀子串，相等的尾串/后缀子串 —— K = 首串后一个</li>
<li>例子<ul>
<li>ababa —— aba，aba</li>
<li>aaaaa —— aaaa，aaaa   (串的首串和尾串长度小于本身)</li>
<li>abc      —— a,c</li>
</ul>
</li>
</ul>
</li>
<li>KMP空间换时间。申请一个和模式串长度相同的整形数组next，next[j] = k；<ul>
<li>next[ j ]，表示Ti和Si失配的时候，子串由 j 回溯到 k；</li>
<li>next[ j ]  ——  <ul>
<li>-1        j==0  ——  <strong>位序为0</strong></li>
<li>max{ k | 0 &lt; k &lt; j &amp;&amp; “T0…T_(k-1) == T_(j-k)…T_(j-1)”（首串和尾串） }</li>
<li>0          其他情况（例如没有首串和尾串、<strong>位序为1</strong>）</li>
</ul>
</li>
<li>串T的next数组<ul>
<li>Good  ——  -1,0,0,0</li>
<li>abc123<strong>a</strong>bcd  ——  -1,0,0,0,0,<strong>0</strong>,1,2,3<ul>
<li><strong>a时，a前面（不加a）没有，所以是0</strong></li>
</ul>
</li>
<li>aaaab   —— -1,0,1,2,3</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>改进的KMP，nextVal[]</p>
<ul>
<li><p>例子</p>
<ul>
<li><p>abc123abcd   ——   <strong>求next  ——  再求nextval</strong></p>
<ul>
<li>next：     -1，0，0，0，0，0，0，1，2，3,</li>
<li>nextval：-1，0，0，0，0，0，-1，0，0，3，<ul>
<li>第一个一定 -1</li>
<li>不匹配时，看next[ j ]处的字符  ==  出错的地方，<ul>
<li>不等于  —— 继承next</li>
<li>等于      —— 继承next处的nextval</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么用nextval</p>
<ul>
<li>失配，查nextval —— <ul>
<li>-1，<strong>i++，j=o</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>bf算法最差O(m*n)，但是常常是O(m+n)</li>
<li>KMP，O(m+n) —— O(m)<ul>
<li>寻找模式串的特征，设计next。</li>
<li>追求目标串不回溯，模式串有规律回溯。减少回溯和比较。</li>
<li>空间换时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>空串（字符数==0）。空格串（字符全是空格）。</p>
</li>
<li><p>S为无重复的长度为n的串，S中的互异的非平凡子串（非空且不同于S本身）的个数</p>
<ul>
<li>子串长度分类：0,1,2,3,4…n。子串数目：1，n，n-1，n-2，…，1</li>
<li>非空，无1。不同于本身—无长度为n的。</li>
<li>高斯的计算方法—— 逆置相加/2</li>
</ul>
</li>
<li><p>KMP中，ij，描述的是位序，别忘了位序从零开始</p>
<ul>
<li>字符串中首字符的位序为0</li>
</ul>
</li>
<li><p>模式串 —— 子串。目标串 —— 主串。</p>
</li>
<li><p>next</p>
<ul>
<li>位序为0,1  —— next 为 -1 和 0</li>
<li>其他看本位之前的，首串尾串的长度（不看本位）</li>
</ul>
</li>
<li><p>nextval</p>
<ul>
<li>先求next</li>
<li>首为   -1</li>
<li>失败时比较失败处和失败处的next处。<ul>
<li>不等于  —— 继承next</li>
<li>等于      —— 继承next处的nextval</li>
<li><strong>同变不同不变</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>nextval简便方法：next + 1</strong></p>
</li>
<li><p>串是一种特殊的字符串，特殊体现在数据元素是一个字符，也就是说<strong>内容受限</strong>的线性结构</p>
</li>
<li><p>回文数</p>
<ul>
<li><p>正反读都一样 —— level，noon</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> S;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>,S);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>, j=S.length()<span class="number">-1</span>; i&lt;j; i++,j--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(S[i]!=S[j])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/07/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>存储结构、结构的特点、二叉树的遍历和其他算法</li>
<li><strong>全员高频</strong></li>
<li>大于 20%</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>顺序存储 ：一组地址连续的存储单元自上而下、自左而右存储。</p>
<ul>
<li>下标反应逻辑关系 —— 父子<ul>
<li>i 的左孩子 2i。右孩子 2i+1。父亲 n/2 “↓”。</li>
</ul>
</li>
<li>编号不一定连续 —— 浪费空间，但是保持了逻辑关系</li>
<li>单支树，需要 2^k - 1个存储单元</li>
</ul>
</li>
<li><p>链式存储</p>
<ul>
<li><p>二叉链表</p>
</li>
<li><p>三叉链表（加了一个parent指针）</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">BTlinklist</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">            Node *left,*right;</span><br><span class="line">            elemType data;</span><br><span class="line">            Node():left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">            Node(elemType val, Node *l = <span class="literal">NULL</span>,Node*r=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                data = val;left = l;right = r;</span><br><span class="line">            &#125;</span><br><span class="line">            ~Node();</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉树的遍历</p>
<ul>
<li>按一定规则和顺序访问所有结点，且只被访问一次<ul>
<li>实质上是，把二叉树的各个结点排列成一个线性序列</li>
</ul>
</li>
<li>DFS：前序，中序，后序</li>
<li>BFS：层次遍历</li>
</ul>
</li>
<li><p>前序遍历  —— <strong>NLR</strong>/NRL</p>
<blockquote>
<ul>
<li>树空？</li>
<li>循环<ul>
<li>访问 R</li>
<li>前序遍历 左子树</li>
<li>前序遍历 右子树</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p><strong>注意以树为单位！进入子树后，子树变树。</strong></p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(T)&#123;</span><br><span class="line">	visit(T);</span><br><span class="line">    preOrder(T-&gt;left);</span><br><span class="line">    preOrder(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>中序遍历</p>
<blockquote>
<ul>
<li>树空？</li>
<li>循环<ul>
<li>中序遍历 左子树</li>
<li>访问 R</li>
<li>中序遍历 右子树```cpp</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>中序遍历，是有序树的顺序序列</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(T)&#123;</span><br><span class="line">    inOrder(T-&gt;left);</span><br><span class="line">    visit(T);</span><br><span class="line">    inOrder(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>后序遍历</p>
<blockquote>
<ul>
<li>树空？</li>
<li>循环<ul>
<li>中序遍历 左子树</li>
<li>访问 R</li>
<li>中序遍历 右子树</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>后序遍历的第一个是最左边的结点</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(T)&#123;</span><br><span class="line">    postOrder(T-&gt;left);</span><br><span class="line">    postOrder(T-&gt;right);</span><br><span class="line">    visit(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>层序遍历</p>
<ul>
<li><p>就是按编码顺序</p>
</li>
<li><p><strong>利用队列</strong></p>
<ul>
<li><p>初始化队列</p>
</li>
<li><p>队列非空，循环</p>
<ul>
<li>出队一个结点N</li>
<li>结点N的左子树入队</li>
<li>结点N的右孩子入队</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">BinaryLinkList</span>&lt;elemType&gt;:</span>:levelOrderTraverse()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            que.push(p);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            p = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                que.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right!= <span class="literal">NULL</span>)</span><br><span class="line">                que.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>中序序列 + 先序/后序  ——  可唯一确定</p>
<ul>
<li>前序 —— 首为ROOT</li>
<li>后序 —— 尾为ROOT</li>
<li>中序 —— 由ROOT划分左右子树</li>
</ul>
</li>
<li><p>层次序列 + 中序序列   ——  可唯一确定</p>
</li>
<li><p>基本算法</p>
<ul>
<li><p>结点总数</p>
<ul>
<li><p>前序遍历二叉树</p>
<ul>
<li><p>空子树 —— 0</p>
</li>
<li><p>非空子树 —— 1 + 左子树 + 右子树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BinaryLinkList&lt;elemType&gt;::size(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(t-&gt;left) + size(t-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求高度</p>
<ul>
<li><p>前序遍历二叉树</p>
<ul>
<li><p>空子树 —— h = 0</p>
</li>
<li><p>非空子树 —— 左右子树大的那个 + 1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">elemtype</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">BinaryLinkList</span>&lt;elemType&gt;:</span>:height(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> lh=height(t-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> rh=height(t-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (lh&gt;rh?lh:rh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求叶子数目</p>
<ul>
<li><p>前序遍历二叉树</p>
<ul>
<li><p>空子树 —— 叶节点0</p>
</li>
<li><p>没有左右孩子 —— 1</p>
</li>
<li><p>非空子树  ——  左子树结点 + 右子树结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">BinaryLinkList</span>&lt;elemType&gt;:</span>:leafNum(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left==<span class="literal">NULL</span> &amp;&amp; t-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> leafNum(t-&gt;left) + leafNum(t-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>一维数组表示一个深度为5，结点数为10的二叉树，求数组长度<ul>
<li>最少：2^4 -1 +1<ul>
<li>第五层只一个结点，且在最左边  —— 最少多少结点问题</li>
</ul>
</li>
<li>最多：2^5  -  1<ul>
<li>第五层只一个几点，且在最右边  ——  最多多少结点问题</li>
</ul>
</li>
</ul>
</li>
<li>先序遍历为 abcd的不同的二叉树<ul>
<li>实际上是，已知结点数，求多少种不同的二叉树 —— 肯特兰数</li>
</ul>
</li>
</ul>
<p>![image-20200525090140991](C:\Users\gao xiwang\AppData\Roaming\Typora\typora-user-images\image-20200525090140991.png)</p>
<ul>
<li><p>二叉树类型 ，别忘单支树，</p>
</li>
<li><p>前序 aebdc，后序bcdea</p>
<ul>
<li>根节点的孩子结点  —— 只有e</li>
<li>前序ae，后序ea，<ul>
<li><strong>假设</strong>a的孩子节点有两个，那么应该 会aex，axe不符合。—— 只有e</li>
</ul>
</li>
</ul>
</li>
<li><p>找出满足下列条件的二叉树</p>
<ul>
<li>先序 NLR，中序LNR，后序LRN，层序NLR</li>
<li>先序==后序<ul>
<li>消去LR，只有根节点</li>
</ul>
</li>
<li>中序==后序<ul>
<li>消去右子树R，每个结点，只有左孩子</li>
</ul>
</li>
<li>先序==中序<ul>
<li>消去左子树L，每个结点，只有右孩子</li>
</ul>
</li>
<li>中序==层序<ul>
<li>消去左子树L，每个结点，只有右孩子</li>
</ul>
</li>
</ul>
</li>
<li><p>一棵非空的二叉树的先序 正好和 后序相反 </p>
<ul>
<li>NLR == reverse(LRN) == NRL,<ul>
<li>消去左子树，或者消去右子树，LR不同时出现 —— 单支树</li>
</ul>
</li>
<li>每个结点最多有一个孩子 —— 单支树<ul>
<li>高度 == 结点数，只有一个叶子</li>
</ul>
</li>
</ul>
</li>
<li><p>表达式树转换为等价的中缀表达式</p>
<ul>
<li><p>先序遍历 —— 前缀</p>
</li>
<li><p>后序遍历 —— 后缀</p>
</li>
<li><p>中序遍历 —— 中缀，但是<strong>没有括号</strong>！</p>
<ul>
<li><p>叶子结点 —— 运算数</p>
</li>
<li><p>非叶子结点 —— 运算符</p>
<ul>
<li><p>每次遇到非叶子结点，都是一个子表达式 —— 加括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expTree::inOrder</span><span class="params">(Node* t, <span class="keyword">int</span> depth)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">	        <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">"  "</span>;	</span><br><span class="line">	    <span class="keyword">else</span>&#123;</span><br><span class="line">    	    <span class="keyword">if</span>(depth &gt; <span class="number">1</span>)</span><br><span class="line">        	    <span class="built_in">cout</span> &lt;&lt; <span class="string">" ( "</span>;</span><br><span class="line">        	inOrder(t-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        	ifnOrder(t-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(depth &gt; <span class="number">1</span>)</span><br><span class="line">            	<span class="built_in">cout</span> &lt;&lt;<span class="string">" ) "</span> ;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;<span class="comment">//if(t)</span></span><br><span class="line">&#125;<span class="comment">// inOrder</span></span><br><span class="line"><span class="comment">//  if(root)	inOrder(root,1);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>前序建立树</p>
<ul>
<li><p>带有外部结点 (标识了空子树的情况) 的前序序列建立二叉树</p>
</li>
<li><p>将树正则化，建立正则二叉树，树中结点的度为 0/2</p>
<ul>
<li>缺少叶子的用 “*”结点代替</li>
</ul>
</li>
<li><p>之后前序遍历（*结点也写上）</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">BinaryLinkList</span>&lt;elemType&gt;:</span>:preOrderCreat(elemType flag,Node* &amp;t)&#123;</span><br><span class="line">        elemType val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span>(val != flag)&#123;	<span class="comment">// 递归出口</span></span><br><span class="line">            t = <span class="keyword">new</span> Node(val);		<span class="comment">//生成根节点</span></span><br><span class="line">            preOrderCreat(flag, t-&gt;left);<span class="comment">//递归左子树</span></span><br><span class="line">            preOrderCreat(flag, t-&gt;right);<span class="comment">//递归右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>p指向的结点是叶子结点，<code>p-&gt;left == NULL &amp;&amp; p-&gt;right == NULL;</code></p>
</li>
<li><p>一个结点的后序遍历，后继结点是右兄弟的左子树的最左边结点</p>
</li>
<li><p>遍历 —— 为了找到一种线性序列</p>
<ul>
<li>前序遍历，先走完最左边的那一条路径</li>
<li>中序遍历，等同于有序树的顺序序列</li>
<li>后序遍历，第一个遍历的是最左最下的两个结点</li>
</ul>
</li>
<li><p>先找树的根，</p>
<ul>
<li>划分子树都含有哪些、多少个结点</li>
<li>找子树的根，继续划分子树</li>
</ul>
</li>
<li><p>二叉链表存储树，后序遍历输出结点，编写算法输出后序遍历（LRN）的逆序（NRL）。</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">BinaryLinkList</span>&lt;elemType&gt;:</span>:postOrder(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            postOrder(t-&gt;left);</span><br><span class="line">            pestOrder(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>关键路径</title>
    <url>/2020/07/25/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>考的少，但是考过大题。</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li>AOE <ul>
<li>顶点 —— 事件</li>
<li>弧     —— 活动</li>
<li>弧上权值 —— 活动持续时间</li>
</ul>
</li>
<li>完成整个工程至少多少时间</li>
<li>哪些活动是影响工程的关键  ——  关键路径（可能不唯一）<ul>
<li><strong>源点到汇点 的最长的路径，会加法就能求</strong><ul>
<li>可以单凭这个求解</li>
</ul>
</li>
</ul>
</li>
<li>e(i) —— 活动ai开始最早的时间</li>
<li>l(i)  —— 活动开始的最晚时间<ul>
<li>关键活动 —— e(i) == l(i)</li>
</ul>
</li>
<li>Ve(j) —— 事件 j ，开始的最早的时间</li>
<li>Vl(j)  —— 事件 j ，开始的最晚的时间</li>
</ul>
<ul>
<li><p>过程（课本上）</p>
<ul>
<li>顶点 —— 事件<ul>
<li>最早时间    Ve(j)，从前往后走<ul>
<li>源点 为  0</li>
<li><strong>选择大的</strong></li>
</ul>
</li>
<li>最晚时间    Vl(j)，从后往前<ul>
<li>汇点 Ve == Vl</li>
<li><strong>选择小的</strong></li>
</ul>
</li>
<li>源点和汇点  Ve == Vl</li>
</ul>
</li>
<li>活动 —— 边&lt; i , j&gt;<ul>
<li>最早时间  e == Ve( i )<ul>
<li>源点的出边 —— 0</li>
</ul>
</li>
<li>最晚时间  l == Vl( j ) - W_边</li>
</ul>
</li>
<li>l == e —— 关键活动 —— 关键路径</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>只有减少关键活动的时间才可能缩短工期</li>
<li>只有减少所有关键路径上的工有的关键活动才可能缩短工期</li>
<li>只有不改变关键路径的前提下减少关键活动才可能缩短工期</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>加快活动缩短整个工期<ul>
<li>所有 关键路径 都被缩短</li>
</ul>
</li>
<li>保存邻接矩阵 的上三角矩阵 <ul>
<li>不保存，主对角线 和 下三角</li>
<li>有向图不对称</li>
<li>无线 —— 无穷，有线 —— 权值</li>
<li><strong>主对角线 —— 0</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>关键路径</tag>
      </tags>
  </entry>
  <entry>
    <title>Huffman树</title>
    <url>/2020/07/25/Huffman%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>概念、特点、构造树、huffman编码</li>
<li>选择判断填空、应用</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li>路径 ： 结点A到结点B 的分支序列</li>
<li>路径长度 ： 路径上分支的数目（边的数目）</li>
<li>完全二叉树 —— 总路径最短</li>
<li>结点的权值 —— 结点被赋予有意义的数字（例如频度）</li>
<li>带权路径长度 —— root 到该节点的路径长度 * <strong>该节点的权</strong></li>
<li><strong>树的带权路径长度 —— 所有leaf</strong> 的带权路径长度之和<ul>
<li>WPL = Σ wi * li</li>
</ul>
</li>
<li>Huffman树，WPL最小的二叉树 （最优二叉树）<ul>
<li>给四个叶子结点abcd，权值2、3、6、9，可以构造多少种形态不同的二叉树<ul>
<li>叶子接安定，全在最下面</li>
<li>单支树，然后安放叶子结点正则化 —— HUffman</li>
</ul>
</li>
<li>wi越大，离根节点越近，越小越远。</li>
<li>是正则二叉树，n1 == 0，<ul>
<li>只有度为0 或 2 的结点</li>
</ul>
</li>
<li>任意非叶子结点的左右子树可以交换，不改变WPL<ul>
<li>树形不唯一，WPL相同</li>
</ul>
</li>
<li>n个叶子结点的Huffamn树 —— 2n-1个结点</li>
</ul>
</li>
<li>Huffman算法构造Huffman树<ul>
<li>由 n 个给定的叶子权值集合，构造含有 n 棵二叉树（只有根节点）</li>
<li>选两棵最小的作为左右子树构造新的二叉树，根节点权值为两个之和</li>
<li>删去选用的两棵，加入新的二叉树</li>
<li>重复</li>
</ul>
</li>
<li>Huffman编码<ul>
<li>得到平均长度最短的编码</li>
<li>前缀码，任何一个字符的编码，都不是另一个字符的编码的前缀。（防止解码出错）</li>
<li>二叉树构造前缀码，Huffman树构造最短的前缀码<ul>
<li>频率作权值构造一棵huffman树</li>
<li>叶子结点对应一个字符</li>
<li>路径上，<strong>左分支0，右分支1。从上向下读</strong></li>
</ul>
</li>
<li>根节点到每个叶子结点路径上的 01 序列即为对应字符的Huffman编码</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>Huffman树一定是正则树，不一定是完全二叉树</p>
<ul>
<li>正则树 只有 n0、n2，无 n1。</li>
</ul>
</li>
<li><p>左分支+右分支 == 父结点权值</p>
</li>
<li><p>每次选取，选最小的两个  —— 叶子结点的位置</p>
</li>
<li><p>认真读题</p>
</li>
<li><p>求WPL</p>
<ul>
<li><p>left、weight、right。—— 前序遍历二叉树</p>
</li>
<li><p><strong>路径长度和层次有关，（和递归栈深度有关）</strong></p>
<blockquote>
<ul>
<li>空子树 —— WPL = 0</li>
<li>没有左右子树 —— 叶子结点，要计算了</li>
<li>非叶子结点， <ul>
<li>WPL ==  左子树叶子结点的带权路径长度、右子树带权路径长度  之和</li>
</ul>
</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL</span><span class="params">(Node* root, <span class="keyword">int</span> d)</span><span class="comment">//d _路径长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;weight * d;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> WPL(root-&gt;left,d+<span class="number">1</span>) + WPL(root-&gt;right, d+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">// 调用 —— WPL(root,0) —— 第L层，路径长度 L-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>任何一个结点的度 —— 0 或 2</p>
</li>
<li><p>叶子结点数 n —— 所有结点 2n-1</p>
</li>
<li><p>树的WPL == 所有叶子结点WPL</p>
</li>
<li><p>从任一结点出发到根的路径上所经过的结点序列按其关键字有序 —— 堆</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Huffman</tag>
      </tags>
  </entry>
  <entry>
    <title>图的定义和存储</title>
    <url>/2020/07/25/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>概念，存储结构</li>
<li>高频：概念术语，邻接矩阵、邻接表的特点</li>
<li>大于等于 15%</li>
<li>选择判断填空应用</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>图graph （V  ,  E）</p>
</li>
<li><p>有向图directed graph &lt; V , E &gt;</p>
<ul>
<li>弧 arc &lt; u , v &gt;</li>
<li>弧尾u。——》弧头，v。</li>
<li>n_v 含义不同于 v_u</li>
</ul>
</li>
<li><p>无向图 undirected </p>
</li>
<li><p>加权图，边带权值</p>
</li>
</ul>
<ul>
<li><p>无向完全图（任意两个顶点都有一条边直接相连）</p>
<ul>
<li>总边 == n*(n-1) / 2</li>
</ul>
</li>
<li><p>有向完全图</p>
<ul>
<li>总边 == n*(n-1)</li>
</ul>
</li>
<li><p>子图subGraph —— 图的一部分（包括自身）</p>
</li>
<li><p>稀疏图和稠密图 ， 边的多少</p>
</li>
<li><p><strong>度</strong> ：</p>
<ul>
<li>入度，有向图进入某个结点的边数</li>
<li>出度，有向图离开某个结点的边数</li>
<li>顶点的度是边数的两倍</li>
</ul>
</li>
<li><p>路径path，</p>
</li>
<li><p>路径长度，路径经过的边的数目，加权图，是权值之和</p>
</li>
<li><p>回路/ 环 cycle 一条路径，第一个顶点和最后一个顶点相同</p>
</li>
<li><p>简单路径，路径上顶点不重复</p>
</li>
<li><p>简单回路，除了第一个和最后一个结点，其余不重复</p>
</li>
<li><p>连通图，在无向图中每一个顶点都是连通的</p>
</li>
<li><p>连通分量，无向图的极大连通子图</p>
<ul>
<li>n个顶点最少 n-1 条边，变成连通图</li>
</ul>
</li>
<li><p>强连通图，有向图中构成环，顶点能互相到达</p>
</li>
<li><p>强连通分量，极大强连通子图</p>
</li>
<li><p>生成树，连通图的极小连通子图</p>
<ul>
<li>无向图</li>
<li>所有n个顶点 + n-1 条边</li>
<li>再加一条边 —— 会形成环/回路</li>
<li>不唯一</li>
</ul>
</li>
<li><p>存储结构 —— 顶点 + 顶点关系（边/弧）</p>
</li>
<li><p>邻接矩阵，有边为 1 </p>
<ul>
<li>一定对称 —— 压缩存储</li>
<li>i / j 行 1 的个数 —— 顶点的度</li>
</ul>
</li>
<li><p>有向图邻接矩阵</p>
<ul>
<li>不一定对称</li>
<li>i 行 —— i 的出度</li>
<li>j 行 —— j 的入度</li>
</ul>
</li>
<li><p>带权图邻接矩阵</p>
<ul>
<li>有边，存权值</li>
<li>无边，存  ∞   </li>
</ul>
</li>
<li><p>邻接矩阵</p>
<ul>
<li><p>图的邻接矩阵唯一的</p>
</li>
<li><p>n个顶点 —— O(n^2)</p>
<ul>
<li>边多边少都这样，有可能浪费空间</li>
<li>存取O(n^2)</li>
</ul>
</li>
<li><p>稀疏矩阵，三元组表</p>
<ul>
<li>起点、终点、权值</li>
</ul>
</li>
<li><p>判断有没有边 O(1)</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点 —— 一维数组 // 边 —— 二维数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">EdgeType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">adjMatrix</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        	VertexType *vertexs;</span><br><span class="line">        	EdegeType **edges;</span><br><span class="line">        	EdgeType noEdge;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> start)</span><span class="keyword">const</span></span>;<span class="comment">//DFS</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>邻接表 adjacency list</p>
<ul>
<li>顶点顺序存储结构，邻接点链式存储结构</li>
<li>边表：为<strong>每一个顶点</strong>建立一个单链表，附设头结点<ul>
<li>隶属顶点的邻接点的边</li>
<li>结点的度数 —— 边表链表的节点的个数<ul>
<li>无向图的边，边表存<strong>两遍</strong></li>
</ul>
</li>
<li>有向图，结点 i <ul>
<li>出度,遍历某个结点的边表，是第 i 个链表的结点数</li>
<li>入度需要遍历整个链表</li>
</ul>
</li>
<li>带权图，to、weight、next</li>
<li>没权图，to、next</li>
</ul>
</li>
<li>顶点表：每一个链表设立一个头结点。<ul>
<li>vertex 数据域存储顶点信息。</li>
<li>firstEdge 指向顶点 Vi 的第一个邻接点。</li>
</ul>
</li>
</ul>
</li>
<li><p>邻接表，图的标准的存储方式</p>
<ul>
<li>表示不唯一</li>
<li>内存 = 结点 + 边</li>
<li>处理时间  = O(V+E)</li>
<li>稀疏图存储比邻接矩阵省<ul>
<li>稀疏： e &lt;&lt; n*(n-1)/2</li>
</ul>
</li>
<li>确定是否有边，最差需要 O(n) 的时间</li>
<li>无向图存储时，一条边存储两次，边表空间浪费一倍</li>
<li>有向图寻找进入某结点的边，非常困难。</li>
</ul>
</li>
<li><p>存储</p>
<ul>
<li><p>边表   </p>
<ul>
<li>边结点： to、weight、next</li>
</ul>
</li>
<li><p>顶点表 </p>
<ul>
<li>顶点结点：vretex（身份和存储的信息）、firstEdge</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">EdgeType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">adjList</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span>&#123;</span></span><br><span class="line">                <span class="keyword">int</span> to;			<span class="comment">//弧头结点的编号</span></span><br><span class="line">                EdgeType weight;</span><br><span class="line">                EdgeType *next;</span><br><span class="line">                edgeNode()&#123;&#125;;</span><br><span class="line">                edgeNode(<span class="keyword">int</span> t,EdgeType w,edgeNode * next)&#123;</span><br><span class="line">                    to = t;</span><br><span class="line">                    weight = w;</span><br><span class="line">                    next = n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//struct</span></span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">verNode</span>&#123;</span></span><br><span class="line">                VertexType vertex;</span><br><span class="line">                edgeNode *firstEdge;</span><br><span class="line">                verNode(edgeNode *h=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    firstEdge = h;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//struct</span></span><br><span class="line">        	</span><br><span class="line">        	verNode *erList;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> start)</span><span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>无限连通图特例，直线、环</p>
</li>
<li><p>顶点度数 == 2 * 边</p>
</li>
<li><p>无向图边数</p>
<ul>
<li>最多，完全图  —— n*(n-1)/2</li>
<li>最少，没有边，全是结点 —— 0</li>
</ul>
</li>
<li><p>非连通无向图，给边数，问至少多少个结点</p>
<ul>
<li>边构成完全图 + 单个结点无边连接</li>
</ul>
</li>
<li><p>无向图 7 个顶点，为了保证图任何情况下都是联通的，需要多少边</p>
<ul>
<li><p>需要六个点完全图，第七个用一条边连上</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20191021/4004164_1571646605821_65248D2CE6D321CF7865E981FDA85DED" alt="img"></p>
</li>
</ul>
</li>
<li><p>边、点、度</p>
<ul>
<li>顶点的度数之和 == 边的两倍</li>
<li>有向图，入度 == 出度</li>
<li>顶点的度数之和 == Σ Vk*k    （度为k的结点个数 * k）</li>
</ul>
</li>
<li><p>n个结点，连通分量（极大连通子图）</p>
<ul>
<li>最少，1</li>
<li>最多，n</li>
</ul>
</li>
<li><p>邻接矩阵</p>
<ul>
<li>对称<ul>
<li>无向图 <ul>
<li>行  /  列中 1 的个数 —— 度数</li>
<li>矩阵中非 0 的个数 —— 2*边（对称）</li>
</ul>
</li>
<li>对称也有可能是对称的</li>
</ul>
</li>
<li>不对称 —— 有向图<ul>
<li>行 —— 出度</li>
<li>列 —— 入度</li>
<li>度 == 入度 + 出度</li>
</ul>
</li>
</ul>
</li>
<li><p>邻接表内存 == 点 + 边</p>
<ul>
<li>邻接矩阵 == 点^2（和边无关）</li>
<li>顶点v，链表中出现的个数 —— 入度</li>
<li>边表的结点 n ， 则边数 —— n/2</li>
</ul>
</li>
<li><p>连通n个结点的有向图 —— n条边（环）</p>
<ul>
<li>无线图 —— n-1 条边（线）</li>
</ul>
</li>
<li><p>有向图，每个顶点的度的最大值 —— 2（n-1）</p>
<ul>
<li>n-1条出边 和 入边</li>
</ul>
</li>
<li><p>N个顶点的连通图的最小生成树 —— n-1条边</p>
</li>
<li><p>连通图</p>
<ul>
<li>无向  :  完全图 —— 最小生成树<ul>
<li>n*(n-1)/2 —— n-1（串）</li>
</ul>
</li>
<li>有向 ： 完全图 —— 最小生成树<ul>
<li>n*(n-1) —— n（环）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>定义</tag>
      </tags>
  </entry>
  <entry>
    <title>鸢尾花-sklearn-决策树</title>
    <url>/2020/07/25/sklearn-%E9%B8%A2%E5%B0%BE%E8%8A%B1-dt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>鸢尾花–机器学习的“hello，world！”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">sklean解决鸢尾花分类</span></span><br><span class="line"><span class="string">并将决策树图可视化</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span>  load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line">iris  = load_iris()</span><br><span class="line"><span class="comment"># iris.target_names</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆一部分数据集作测试数据 idx —— index</span></span><br><span class="line">test_idx = [<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>]</span><br><span class="line"><span class="comment"># training set</span></span><br><span class="line">train_target = np.delete(iris.target, test_idx)</span><br><span class="line">train_data = np.delete(iris.data, test_idx, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># testing set</span></span><br><span class="line">test_target = iris.target[test_idx]</span><br><span class="line">test_data = iris.data[test_idx]</span><br><span class="line"><span class="comment"># classifier</span></span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf.fit(train_data,train_target)</span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">print(clf.predict(test_data)) <span class="comment"># 得到 label</span></span><br><span class="line"><span class="comment"># viz code —— Visualization</span></span><br><span class="line"><span class="keyword">from</span> sklearn.externals.six <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> pydot</span><br><span class="line">dot_data = StringIO()</span><br><span class="line">tree.export_graphviz(clf,</span><br><span class="line">                         out_file=dot_data,</span><br><span class="line">                         feature_names=iris.feature_names,</span><br><span class="line">                         class_names=iris.target_names,</span><br><span class="line">                         filled=<span class="literal">True</span>,rounded=<span class="literal">True</span>,</span><br><span class="line">                         impurity=<span class="literal">False</span>)</span><br><span class="line">graph = pydot.graph_from_dot_data(dot_data.getvalue())</span><br><span class="line">graph[<span class="number">0</span>].write_pdf(<span class="string">"iris.pdf"</span>) <span class="comment"># 生成pdf</span></span><br></pre></td></tr></table></figure>
<p>PDF:<br><img src="2020-07-29-19-46-26.png" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2020/07/25/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00考点"><a href="#00考点" class="headerlink" title="00考点"></a>00考点</h3><ul>
<li>概念、特点。头结点的作用。基础算法(遍历、查找、删除、插入、逆置)</li>
<li>选、填、判断、算法设计</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>线性表的链式存储方式，值域+指针域。</p>
<ul>
<li>指针/地址 指示逻辑关系</li>
</ul>
</li>
<li><p><strong>头指针指向头结点(链表的第一个结点)。或者首元结点</strong></p>
</li>
<li><p><strong>头结点指向首元结点/第一元素结点（第一个存储元素的）。</strong></p>
</li>
<li><p><strong>尾指针指向NULL：</strong></p>
</li>
<li><p>查找元素只能遍历。</p>
</li>
<li><p>单链表，由头指针唯一确定，唯一标识。头指针常常作链表的名字。</p>
<ul>
<li>链表结点都是动态的，都没有名字。</li>
</ul>
</li>
<li><p>空表</p>
<ul>
<li>没有头结点：head(头指针)指向NULL</li>
<li>有头结点   ：head指向头结点，头结点指针指向NULL</li>
</ul>
</li>
<li><p>头结点意义</p>
<ul>
<li>表头位置插入和删除没有头结点，就得修改头指针。</li>
<li>头结点，使得操作统一</li>
<li>常常不放数据，或者放<strong>哨兵</strong>数据</li>
</ul>
</li>
<li><p>结点定义</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        	ElemType data;</span><br><span class="line">        	Node* next；</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// cpp struct可以定义函数 —— 下面是两个构造函数</span></span><br><span class="line">            Node(<span class="keyword">const</span> ElemType val, Node* p=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                data = val;</span><br><span class="line">                next = p;</span><br><span class="line">            &#125;</span><br><span class="line">        	Node(Node* p)&#123;</span><br><span class="line">                next = p;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>头指针， head</p>
<ul>
<li><p>初始化——给头指针赋值： <code>head = new Node(NULL);</code></p>
<ul>
<li><p>没有头结点 —— <code>head = NULL</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请空间，有时候失败</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">throw</span> FalltoNew();</span><br><span class="line">Node&lt;ElemType&gt;*p = <span class="keyword">new</span> Node&lt;ElemType&gt;(value,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">(*p).data;</span><br><span class="line">p-&gt;data;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>每一个结点， next</p>
<ul>
<li>逻辑上的后继结点</li>
</ul>
</li>
<li><p>基础算法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 01 遍历(工作指针)		O(n) —— O(1)</span></span><br><span class="line">Node *p = head-&gt;next;	<span class="comment">// p指向首元结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;		<span class="comment">// p移出链表之后变NULL</span></span><br><span class="line">	visit(p);	</span><br><span class="line">    p = p-&gt;next; <span class="comment">// 向后移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求表长</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node *p = head-&gt;next;	<span class="comment">// p指向首元结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;		<span class="comment">// p移出链表之后变NULL</span></span><br><span class="line">	visit(p);	</span><br><span class="line">    p = p-&gt;next; <span class="comment">// 向后移动</span></span><br><span class="line">	++count;</span><br><span class="line">&#125;</span><br><span class="line">Link_List.length = count;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 02 查找(返回位序)</span></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>；		<span class="comment">// 记录位序</span></span><br><span class="line">Node *p = head-&gt;next;	<span class="comment">// p指向首元结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != val)&#123; <span class="comment">// p移出链表之后变NULL //</span></span><br><span class="line">    p = p-&gt;next; <span class="comment">// 向后移动</span></span><br><span class="line">	++idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line"><span class="keyword">else</span>		<span class="keyword">return</span> idx;</span><br><span class="line"><span class="comment">// 最好——O(1)</span></span><br><span class="line"><span class="comment">// 最坏——O(n)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 03 插入元素cur到pre之后  </span></span><br><span class="line">cur-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = cur;</span><br><span class="line"><span class="comment">// —— 要插入必须要知道前一个元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在p之前插入val</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pre = head;</span><br><span class="line"><span class="keyword">while</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;next!=p)&#123;  <span class="comment">// 查找pre！！！！</span></span><br><span class="line">	pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!pre)	<span class="keyword">throw</span> NotExist();</span><br><span class="line">s = <span class="keyword">new</span> Node&lt;ElemType&gt;();<span class="comment">//申请内存，创建新结点</span></span><br><span class="line">s-&gt;data = val;</span><br><span class="line">s-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;xnext = s;</span><br><span class="line"><span class="comment">// 最好——O(1)</span></span><br><span class="line"><span class="comment">// 最坏——O(n)</span></span><br></pre></td></tr></table></figure>



<ul>
<li>已知p指针，不知前驱pre怎么插入到p前？？？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没法插到前面！  // 先插入，之后交换数据 // 不要忘记每个结点都是没有名字的</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pre-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>; 	<span class="comment">//防止野指针</span></span><br><span class="line"><span class="comment">// 删除p需要知道p的pre</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除第idx个结点 —— 需要知道 第 idx-1个结点的位置</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断位置合法性</span></span><br><span class="line"><span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= <span class="built_in">list</span>.length)	<span class="keyword">throw</span> illegal_idx();</span><br><span class="line">pre = head; count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 找到pre —— idx-1</span></span><br><span class="line"><span class="keyword">while</span>(count&lt;idx &amp;&amp; pre-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    pre = pre-&gt;next;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line">p = pre-&gt;next;</span><br><span class="line">pre-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>头插法</p>
<ul>
<li>插入到头结点之后，首元结点之前</li>
<li>链表顺序和插入顺序相反 (逆置)</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = s;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>尾插法</p>
<ul>
<li><p>链表顺序和插入顺序相同</p>
</li>
<li><p>需要尾指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail-&gt;next = s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>逆置</p>
<ul>
<li>断开头结点链接，构造空链表。遍历，而后头插法到头结点后方</li>
<li>头结点，工作指针p，接引指针q</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node *p,*q;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>; <span class="comment">// not head = NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>链表的特点<ul>
<li>不要求物理地址连续</li>
<li>用的时候申请，不用的时候释放</li>
<li>插入、删除，不用移动元素。顺序表平均移动一半</li>
<li>不能随机存取。查找只能遍历，断链就断处之后的失去一部分</li>
<li>空间开销大，存储密度小。—— 指针域</li>
<li>动态变化数据的理想选择。不必事先估计存储空间</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>链表不能随机存取</p>
</li>
<li><p>头结点的目的</p>
<ul>
<li>运算统一和方便实现</li>
</ul>
</li>
<li><p>链表题常常需要画图！！</p>
</li>
<li><p>判空</p>
<ul>
<li>有头结点 —— <code>head-&gt;next == NULL</code></li>
<li>无 —— <code>head == NULL</code></li>
</ul>
</li>
<li><p>合并非递减有序A,B，利用原空间。 </p>
<ul>
<li>逻辑上是ABC三个表，AB往C上接</li>
<li>一个指针就可以表示一个表（不需要有实在的内存，之后可以用指针划内存过来）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node *pb, *pa, *C,*pc;</span><br><span class="line"></span><br><span class="line">pa = A-&gt;next; A-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">pb = B-&gt;next; B-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">C = A;	pc = C-&gt;next; </span><br><span class="line"><span class="keyword">delete</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(pb!=<span class="literal">NULL</span> &amp;&amp; pa!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    qb = qb-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(pa.val &lt;= pb.val)&#123;   	<span class="comment">// 插入pa</span></span><br><span class="line">        pc-&gt;next = pa-&gt;next;</span><br><span class="line">        pc = pa;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;						<span class="comment">// 插入pb</span></span><br><span class="line">        pc-&gt;next = pb;</span><br><span class="line">        pc = pb;		<span class="comment">// 省去接引指针</span></span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长度不一致</span></span><br><span class="line"><span class="keyword">if</span>(pa!=<span class="literal">NULL</span>)	pc-&gt;next = pa;</span><br><span class="line"><span class="keyword">if</span>(pb!=<span class="literal">NULL</span>)	pc-&gt;next = pb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> C;</span><br></pre></td></tr></table></figure>

<ul>
<li>倒数第k个元素 <ul>
<li>01 正数第 n-k 个</li>
<li>02 距离为k的两个指针，后面那个结束，—— 前面那个倒数第k个<ul>
<li>(默认长度大于k) —— 但是需要验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">q = <span class="built_in">list</span>;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; i&lt;k)&#123;</span><br><span class="line">	++i;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!p)&#123;</span><br><span class="line">	q = q-&gt;next;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除绝对值相等的重复元素(只保留第一个)。所有绝对值 &lt; n。要求时间尽可能高效<ul>
<li>01 二重循环</li>
<li>02 辅助数组帮忙记录是否重复。空间换时间</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rec[n];</span><br><span class="line">Node *pre = head;</span><br><span class="line">Node *p   = pre-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>)	retunrn <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!p)&#123;		<span class="comment">// 遍历链表</span></span><br><span class="line">	<span class="keyword">if</span>(rec[p.val] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    	pre = pre-&gt;next;</span><br><span class="line">    	p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        rec[p.vla] = <span class="number">1</span>;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        p = pre -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表访问第i个 —— O(n)</li>
<li>无后继结点 <code>p-&gt;next = NULL;</code></li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>统计</title>
    <url>/2020/07/25/%E6%80%BB%E4%BD%93%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python绘制饼状图</p>
<p><img src="2020-07-29-21-43-07.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">add = <span class="number">12</span>+<span class="number">14</span>+<span class="number">1</span>+<span class="number">5</span>+<span class="number">1</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'Microsoft YaHei'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">edu=(<span class="number">12</span>/add, <span class="number">14</span>/add, <span class="number">1</span>/add, <span class="number">5</span>/add, <span class="number">1</span>/add, <span class="number">2</span>/add, <span class="number">1</span>/add)</span><br><span class="line">labels=(<span class="string">'算法'</span>,<span class="string">'数据结构'</span>,<span class="string">'编程语言'</span>, <span class="string">'工具'</span>,<span class="string">'动态规划'</span>,<span class="string">'机器学习'</span>,<span class="string">'计算机基本概念'</span>)</span><br><span class="line">explode=[<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">color=[<span class="string">'yellow'</span>,<span class="string">'red'</span>,<span class="string">'brown'</span>,<span class="string">'green'</span>,<span class="string">'purple'</span>, <span class="string">'pink'</span>, <span class="string">'blue'</span>]</span><br><span class="line">plt.axes(aspect=<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.pie(x=edu,labels=labels,autopct=<span class="string">'%.1f%%'</span>,</span><br><span class="line">explode=explode,colors=color,</span><br><span class="line">wedgeprops=&#123;<span class="string">'linewidth'</span>:<span class="number">1.5</span>,<span class="string">'edgecolor'</span>:<span class="string">'black'</span>&#125;,</span><br><span class="line">textprops=&#123;<span class="string">'fontsize'</span>:<span class="number">10</span>,<span class="string">'color'</span>:<span class="string">'black'</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'文档分类的饼状分布图'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>动态查找表</title>
    <url>/2020/07/25/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li><strong>二叉查找树</strong></li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>Binary Search Tree</p>
<ul>
<li><p>平均高度 log2(n) ——O( log2(n) )</p>
<blockquote>
<ul>
<li>空</li>
<li>非空<ul>
<li>左子树非空，左子树 &lt; root</li>
<li>右子树非空，右子树 &gt; root</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>中序遍历一棵二叉查找树 —— 得到，有序序列</p>
</li>
<li><p>有序序列构造二叉查找树 —— 得到，单支树</p>
<ul>
<li><p>退化成线性序列 —— O(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">BinarySearchTree</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">                T data;</span><br><span class="line">                Node*left, *right;</span><br><span class="line">                Node(<span class="keyword">const</span> T &amp;val, Node* lt=<span class="literal">NULL</span>, Node* rt=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    data = val;</span><br><span class="line">                    left = l;</span><br><span class="line">                    right = r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        	Node *root;<span class="comment">//根节点是唯一标志</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归定义 —— 递归实现</p>
</li>
</ul>
</li>
<li><p>查找 （单支树时退化）</p>
<blockquote>
<ul>
<li>== root 返回</li>
<li>&lt;   root 递归查找左子树</li>
<li>大于root 递归查找右子树</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">BinarySearch</span>&lt;T&gt;:</span>:search(<span class="keyword">const</span> T &amp;k, Node *t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; t-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> search(k, t-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; t-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> search(k, t-。right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">BinarySearch</span>&lt;T&gt;:</span>:search_notRecursive(<span class="keyword">const</span> T &amp;k, Node *t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; t-&gt;data)</span><br><span class="line">                t = t-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; t-&gt;data)</span><br><span class="line">                t = t-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                reutrn <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ASL 同二叉判定树</li>
<li>查找性能<ul>
<li>走了一条 root到key / 空结点 的路径</li>
<li>最好情况<ul>
<li>二叉查找树的深度和二叉判定树的高度相同。</li>
</ul>
</li>
<li>最差情况<ul>
<li>单支树，变成顺序查找 ASL = (n+1)/2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li><p>新插入的一定是叶子结点</p>
<blockquote>
<ul>
<li>空树 —— 作根</li>
<li>非空<ul>
<li>k == root ，无需插入</li>
<li>k &lt; root —— 插入到左子树</li>
<li>k &gt; root —— 插入到右子树</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> &amp;val, Node * &amp;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">            t = <span class="keyword">new</span> Node(k, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; t-&gt;data)</span><br><span class="line">            insert(k,t-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;data &lt; k)</span><br><span class="line">            insert(k, t-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>插入操作创建二叉树</p>
<ul>
<li>由序列生成，选择在左子树还是右子树 —— L&lt;N&lt;R</li>
</ul>
</li>
<li><p>删除（难点）</p>
<ul>
<li><p>需要删除之后仍然保持性质。</p>
</li>
<li><p>过程</p>
<blockquote>
<ul>
<li>空树 —— pass</li>
<li>小于根节点 —— 左子树上查找和删除</li>
<li>大于根节点 —— 右子树上查找和删除</li>
<li>等于根节点 —— 此时找到要删除的结点</li>
</ul>
</blockquote>
</li>
<li><p>分情况</p>
<ul>
<li>叶子结点<ul>
<li>直接删除，父节点指针域 NULL</li>
</ul>
</li>
<li>有一个孩子的<ul>
<li>删除，用孩子替换，改变父指针指向，</li>
</ul>
</li>
<li>有两个孩子的<ul>
<li>选谁替补 —— 维持二叉查找树特性不变</li>
<li>中序序列中紧靠着被删除结点的结点</li>
<li>左子树中最大的结点(左子树最右) / 右子树中最小的结点(右子树最左)</li>
</ul>
</li>
</ul>
</li>
<li><p>递归删除算法</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:remove(<span class="keyword">const</span> T &amp;k, Node* &amp;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; t-&gt;data)</span><br><span class="line">            remove(k,t-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; t-&gt;data)</span><br><span class="line">            remove(k, t-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left!=<span class="literal">NULL</span> &amp;&amp; t-&gt;right!=<span class="literal">NULL</span>)&#123;<span class="comment">//两个孩子，采用左子树最大值</span></span><br><span class="line">            Node *temp = t-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(temp-&gt;right!=<span class="literal">NULL</span>)<span class="comment">// 左子树最右边——左子树最大值</span></span><br><span class="line">                temp = temp-&gt;right;</span><br><span class="line">            </span><br><span class="line">            t-&gt;data = temp-&gt;data;	<span class="comment">//替换</span></span><br><span class="line">            remove(temp-&gt;data, t-&gt;left);	<span class="comment">//删除替换上来的结点的原位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//只一个孩子//没有孩子</span></span><br><span class="line">            Node *temp = t;</span><br><span class="line">            t = (t-&gt;left !=<span class="literal">NULL</span>)?t-&gt;left:t-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性能</p>
<ul>
<li>最好 —— 二叉查找树，是一棵判定树 —— log2(n)</li>
<li>最差 —— 单支树，—— O( (n+1)/2 ) —— O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>查找二叉树的某一条查找路径 —— 单支树</li>
<li>删除某个结点，再插入某个结点<ul>
<li>叶子 —— 还是原位</li>
<li>非叶子 —— 不是原位</li>
<li>插入时一定是作为叶子插入</li>
</ul>
</li>
<li>abcdefghijklmnopqrstuvwxyz —— 比较字符串</li>
<li>序列有序 —— 形成单支树</li>
<li>二叉排序树查找过程中也是逐渐缩小范围的思想。</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>排序总结</title>
    <url>/2020/07/25/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h1><p><img src="https://upload-images.jianshu.io/upload_images/273973-19cf4a1e58b6ebaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/865/format/webp" alt="img![img](https://upload-images.jianshu.io/upload_images/273973-19cf4a1e58b6ebaf.png?imageMogr2/auto-orient/strip|imageView2/2/w/865/format/webp)"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序总结</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/07/25/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>有向无环图的顶点的排序</p>
<ul>
<li>AOV网络，<ul>
<li><strong>顶点表示活动/任务，弧表示活动或任务之间的优先关系</strong></li>
</ul>
</li>
<li>拓扑序列 Topological Order <ul>
<li>存在 vi 到 vj 的路径，则顶点 vi 排在 vj 的前面。</li>
</ul>
</li>
<li>拓扑排序，构造拓扑序列<ul>
<li>解决先决条件问题，以某种线性顺序来组织多项任务。</li>
<li>例如教学规划和排课。</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤</p>
<blockquote>
<ul>
<li>找一个入度为0的顶点（无前驱），（所有先决条件被解决）</li>
<li>删除该顶点和他的所有出边（邻接点的入度 - 1）</li>
</ul>
</blockquote>
</li>
<li><p>结果</p>
<ul>
<li>输出全部顶点，成功得到拓扑排序</li>
<li>还有顶点未输出，说明<strong>有环</strong>，剩余顶点的入度全都不为0。</li>
</ul>
</li>
<li><p>计算和存储顶点的入度</p>
<ul>
<li>inDegree[n]，表示各个顶点的入度。</li>
<li>边数减少，逻辑上删除某点和该点的所有出边操作——邻接点入度-1</li>
</ul>
</li>
<li><p>为了方便查找入度为0的顶点，另外设置一个存储空间暂存。</p>
<ul>
<li>栈 / 队列—— 可能导致排序结果不同</li>
</ul>
</li>
</ul>
<ul>
<li><p>队列实现拓扑排序</p>
<blockquote>
<ul>
<li>计算每一个顶点的入度，存入 inDegree[ ]</li>
<li>遍历inDegree，0 的入队</li>
<li>队列非空<ul>
<li>队首出队一个入度为0的结点，并输出。</li>
<li>将以该点为尾的所有邻接点入度 - 1</li>
<li>若该邻接点的入度为 0 ，将其入队</li>
</ul>
</li>
<li>此时若无顶点没输出 —— 成功</li>
<li>若有 —— 则图中有环，失败</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于邻接表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">Edgetype</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">adjList</span>&lt;VertexType,EdgeType&gt;:</span>:topSort()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        edgeNode *p;</span><br><span class="line">        <span class="keyword">int</span> i,curNode,count=<span class="number">0</span>,*inDegree=newint[verNum];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)&#123;<span class="comment">//初始化</span></span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)&#123;	<span class="comment">// 求入度</span></span><br><span class="line">            <span class="comment">//每一个顶点</span></span><br><span class="line">            <span class="keyword">for</span>(p=verList[i].firstEdge; p!=<span class="literal">NULL</span>; p=p-&gt;next)</span><br><span class="line">                <span class="comment">//每一个顶点的邻接点</span></span><br><span class="line">                ++inDegree[p-&gt;to];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;vexNum; ++i)&#123;	<span class="comment">//入度为0的顶点入队列</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[p-&gt;to] == <span class="number">0</span>)</span><br><span class="line">                Q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            curNode = Q.front();<span class="comment">//队头出顶点</span></span><br><span class="line">            Q.pop();</span><br><span class="line">            visit(verList[curNode].vertex);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 出顶点，其邻接点入度-1，变0的入队列	</span></span><br><span class="line">            <span class="comment">// 遍历邻接点，需要一个循环，并且注意for的形式</span></span><br><span class="line">            <span class="keyword">for</span>(p=verList[curNode].firstEdge; p!=<span class="literal">NULL</span>; p=p-&gt;next)</span><br><span class="line">                <span class="keyword">if</span>(--inDegree[p-&gt;to]==<span class="number">0</span>)</span><br><span class="line">                    Q.push(p-&gt;to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(count==verNum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同DFS</p>
<ul>
<li>每一条边处理一次（减少入度）</li>
<li>每个点处理一次（入度为0则入，入度变0则入）</li>
</ul>
</li>
<li><p>邻接表</p>
<ul>
<li>T(n) == O(n+e)</li>
</ul>
</li>
<li><p>邻接矩阵</p>
<ul>
<li>T(n) == O(n^2)</li>
</ul>
</li>
<li><p>S(n) == O(n)</p>
</li>
<li><p>怎么知道图中所有顶点的入度</p>
<ul>
<li>遍历 + 计算</li>
</ul>
</li>
<li><p>可以用栈取代队列</p>
<ul>
<li>排序结果可能不同</li>
<li>出队列改成出栈。</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>拓扑序列的个数</p>
<ul>
<li>根据过程列出所有可能</li>
</ul>
</li>
<li><p>回路不是简单路径（路径中所有顶点不重复）</p>
</li>
<li><p>稀疏图 —— 邻接表</p>
</li>
<li><p>稠密图 —— 邻接矩阵</p>
</li>
<li><p>有回路，无拓扑序列</p>
</li>
<li><p>邻接矩阵，有向图，主对角线以下的元素都是零，该图拓扑序列</p>
<ul>
<li><p>存在，可能不唯一</p>
<blockquote>
<ul>
<li>主对角线 —— i == j</li>
<li>以上         —— i  &lt;  j  —— 弧由小顶点，指向大顶点。<ul>
<li>以下         —— i  &gt;  j</li>
</ul>
</li>
<li><strong>全都是”以上“的，“以下全是0” —— 不存在回路/环</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>两种极端情况</strong></p>
<ul>
<li>全0</li>
<li>全1</li>
</ul>
</li>
</ul>
</li>
<li><p>有向图具有拓扑排序序列 —— 邻接矩阵必为 <strong>一般矩阵</strong></p>
<ul>
<li>没有环就能拓扑排序</li>
<li>环 —— 拓扑排序的判别条件</li>
</ul>
</li>
<li><p>邻接矩阵为<strong>三角</strong>，有向图具有<strong>有序的</strong>拓扑排序序列</p>
</li>
<li><p>判断有环</p>
<ul>
<li>拓扑排序</li>
<li>DFS   —— 可能会走回标记过的结点</li>
</ul>
</li>
<li><p>拓扑序列的前后 —— 有向边的指向</p>
<ul>
<li>Vi 在 Vj 前 —— 不存在从Vj到Vi的路径</li>
</ul>
</li>
<li><p>拓扑序列的最后一个顶点 —— <strong>出度</strong>为0</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历</title>
    <url>/2020/07/25/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>DFS、BFS、生成树、生成森林</li>
<li>重点：DFS、BFS</li>
<li>选择填空判断应用算法</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>每个顶点都访问一次且只一次</p>
<ul>
<li>非连通图 —— 无法从一个结点开始之后到达别的所有</li>
<li>回路 —— 死循环</li>
</ul>
</li>
<li><p>标志位 mark bit</p>
<ul>
<li>初始化为0</li>
<li>访问之后变1</li>
</ul>
</li>
<li><p>DFS</p>
<blockquote>
<ul>
<li>选定一个未被访问的顶点 v ，访问并作已经访问的标志</li>
<li>然后依次从 v 的未访问的邻接点出发DFS</li>
<li>重复至所有和 v 有路径相通的顶点被访问到</li>
<li>如果还有未访问的顶点（非连通图），再选取，并重复</li>
</ul>
</blockquote>
<ul>
<li>存储结构不确定，遍历结果可能不唯一。有了存储结构 —— 唯一</li>
</ul>
</li>
<li><p>邻接表</p>
<ul>
<li><p>数组 visited，作mark bit</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">EdgeType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">adjList</span>&lt;VertexType, EdgeType&gt;:</span>: DFStraverse() <span class="keyword">const</span>&#123; <span class="comment">// DFS接口函数，</span></span><br><span class="line">        <span class="keyword">int</span> i, j=<span class="number">0</span>, count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;verNum;++i)&#123;<span class="comment">//初始化</span></span><br><span class="line">            visit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                DFS(i);</span><br><span class="line">                count++;	<span class="comment">// 统计连通分量个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">EdgeType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">adjList</span>&lt;VertexType, EdgeType&gt;:</span>: DFS(<span class="keyword">int</span> start)<span class="keyword">const</span>&#123;</span><br><span class="line">        visit(verList[start]);<span class="comment">//访问</span></span><br><span class="line">        visited[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        edgeNode *p = verList[start].firstEdge;  <span class="comment">// 遍历单链表 —— 工作指针</span></span><br><span class="line">        <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">            <span class="comment">//遍历单链表		// to弧头顶点</span></span><br><span class="line">            <span class="keyword">if</span>(visited[p-&gt;to] == <span class="number">0</span>)</span><br><span class="line">                DFS(p-&gt;to);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>DFS T(N)</p>
<ul>
<li>邻接矩阵 —— O(n^2)</li>
<li>邻接表     —— O(e+n)</li>
</ul>
</li>
<li><p>BFS （类似层次遍历，借助<strong>队列</strong>）</p>
<blockquote>
<ul>
<li>选一个未被访问过的作起点，访问，更新 mark bit</li>
<li>依次访问和顶点邻接的未被访问过的<strong>全部邻接点</strong><ul>
<li>从这些邻接点出发，分别访问其各自的未被访问的邻接点</li>
</ul>
</li>
<li>重复到所有与起点有路径的结点都被放问完毕</li>
<li>关于非连通，重复过程</li>
</ul>
</blockquote>
<ul>
<li><p>不给处存储结构也不唯一</p>
<blockquote>
<ul>
<li>初始化队列</li>
<li>起点入队</li>
<li>队非空<ul>
<li>队头出队，访问，标记</li>
<li>访问邻接点，并标记，依次入队</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">EdgeType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">adjList</span>&lt;VertexType, EdgeType&gt;:</span>: BFStraverse()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v,i,count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)   <span class="comment">//初始化</span></span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)&#123;	<span class="comment">//选择i为起点，防止非连续</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            visit(verList[i].vertex);</span><br><span class="line">            visited[i] = <span class="number">1</span>;<span class="comment">//先访问，后入队。也可以先入队后访问</span></span><br><span class="line">            Q.push(i);<span class="comment">//起点入队</span></span><br><span class="line">            </span><br><span class="line">            edgeType *p;</span><br><span class="line">            <span class="keyword">while</span>(!Q.empty())&#123;	</span><br><span class="line">                v = Q.front();</span><br><span class="line">                Q,pop();<span class="comment">//	起点出队</span></span><br><span class="line">                p = verList[v].firstEdge;<span class="comment">//邻接链表中的 邻接点单链表</span></span><br><span class="line">                <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visited[p-&gt;to] == <span class="number">0</span>)&#123;</span><br><span class="line">                        visit(p-&gt;to);</span><br><span class="line">                        visited[p-&gt;to] = <span class="number">1</span>;</span><br><span class="line">                        Q.push(p-&gt;to)；</span><br><span class="line">						<span class="comment">// 访问邻接点，邻接点入队。</span></span><br><span class="line">                    &#125; <span class="comment">//if</span></span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;<span class="comment">//while</span></span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//func</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>BFS</p>
<ul>
<li>T(N)<ul>
<li>邻接表 ——O(e+n)</li>
<li>邻接矩阵—— O(n^2)</li>
</ul>
</li>
<li>S(N)<ul>
<li>O(n)  —— visited向量</li>
</ul>
</li>
</ul>
</li>
<li><p>生成树</p>
<ul>
<li><p>连通图的极小连通子树</p>
</li>
<li><p>n个顶点，n-1条边</p>
</li>
<li><p>不唯一</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>DFS生成树</p>
</li>
<li><p>BFS生成树</p>
</li>
<li><p>非连通</p>
<ul>
<li>生成森林</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>深度优先遍历 不同序列的数目<ul>
<li>先画图</li>
<li>不断尝试</li>
</ul>
</li>
<li>邻接矩阵，<ul>
<li>行是往外指</li>
<li>列是指向自己的</li>
</ul>
</li>
<li>邻接表<ul>
<li>单链表 —— 直接邻接点</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>图的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>插入/交换排序</title>
    <url>/2020/07/25/%E6%8F%92%E5%85%A5-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li><p>插入 —— 直接、折半、希尔</p>
</li>
<li><p>交换 —— 冒泡、快速</p>
</li>
<li><p>高频考点 —— <strong>手工模拟算法，每一趟排序的结果</strong></p>
</li>
<li><p>10%</p>
</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>按照关键字，形成非递减/非递增的序列</p>
<ul>
<li>内排序：数据量小，内存中</li>
<li>外排序：数据量大，外存中存储，内存中排序</li>
<li>稳定性：相同关键字的相对位置不变</li>
</ul>
</li>
<li><p>衡量标准</p>
<ul>
<li>T(n)、S(n)、算法本身的繁杂程度</li>
</ul>
</li>
</ul>
<ul>
<li><p>直接插入排序 Straight Insertion Sort：</p>
<ul>
<li>原序列 data[0,1,2….,n-1]</li>
<li>初始化是data[0]自己形成有序序列</li>
<li>依次将 data[ i ]插入到 0~i-1 有序子列中去</li>
</ul>
</li>
<li><p>移动元素的策略</p>
<ul>
<li><p>temp 保存要插入的元素，之后找到位置，向后移动腾空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">straight_Sort</span>(<span class="title">T</span> <span class="title">data</span>[],<span class="title">int</span> <span class="title">size</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos,j;</span><br><span class="line">    T temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始data[0]是有序的</span></span><br><span class="line">    <span class="keyword">for</span>(pos=<span class="number">1</span>; pos&lt;size; ++pos)&#123;	<span class="comment">//遍历向量</span></span><br><span class="line">        temp = data[pos];	<span class="comment">//对于 data[j]</span></span><br><span class="line">        <span class="keyword">for</span>(j=pos<span class="number">-1</span>; temp&lt;data[j]; --j)<span class="comment">//后向前移动比大于data[j]的</span></span><br><span class="line">            data[j+<span class="number">1</span>] = data[j];</span><br><span class="line">        data[j+<span class="number">1</span>] = temp;<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>稳定</p>
</li>
<li><p>空间 O(1)</p>
</li>
<li><p>最好 —— 比较n-1，移动2(n-1)，O(n)</p>
</li>
<li><p>最差 —— O(n^2)</p>
<ul>
<li>比较 —— n*(n-1)/2        == Σ i</li>
<li>移动 —— (n-1)(n+4)/2   == Σ( i + 2 )</li>
</ul>
</li>
<li><p>适用于排序元素较少，基本有序(效率最高)</p>
</li>
</ul>
</li>
<li><p>折半插入排序</p>
<ul>
<li><p>折半查找，查找插入位置</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">BinaryInsert_Sort</span>(<span class="title">T</span> <span class="title">data</span>[],<span class="title">int</span> <span class="title">size</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos,j, low, high, mid;</span><br><span class="line">    T temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始data[0]是有序的</span></span><br><span class="line">    <span class="keyword">for</span>(pos=<span class="number">1</span>; pos&lt;size; ++pos)&#123;	<span class="comment">//遍历向量</span></span><br><span class="line">        temp = data[pos];	<span class="comment">//对于 data[j]</span></span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = pos - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;data[mid])</span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// low 是大于pos的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(j=pos<span class="number">-1</span>; temp&gt;low; --j)<span class="comment">//后向前移动比大于data[j]的</span></span><br><span class="line">            data[j+<span class="number">1</span>] = data[j];</span><br><span class="line">        data[low] = temp;<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>T(n) = O(n^2)<ul>
<li>减少比较但是，不减少移动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>希尔排序( 缩小增量排序 )</p>
<ul>
<li><p>减少记录个数（分组） &amp; 基本有序（分别排序）</p>
</li>
<li><p>待划分的记录划分成几组，间距相同的分作一组，进行直接插入排序，最后对整个记录直接插入排序</p>
<ul>
<li><p>直接插入 —— 比较+记录+移动</p>
<blockquote>
<ul>
<li>选取增量，gap &lt; n。分成gap组</li>
<li>间距为gap的进行直接插入排序</li>
<li>缩小增量gap直到1（例如：5,3,1）</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>gap选取</p>
<ul>
<li><p>Shell提出<code>gap /= 2</code>，但是可能存在重复划分 </p>
<ul>
<li>gap = 8,4,2</li>
</ul>
</li>
<li><p>Knuth教授：<code>gap = gap/3 + 1</code>，</p>
</li>
<li><p>Hibbard ：gap = 2^k - 1</p>
</li>
<li><p>共识 —— 尽量选取质数、第一个 &lt; n，做后一个是1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Shell_Sort</span>(<span class="title">T</span> <span class="title">data</span>[], <span class="title">int</span> <span class="title">size</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> gap, pos, j;</span><br><span class="line">    T temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(gap=size/<span class="number">2</span>; gap&gt;<span class="number">0</span>; ++pos)&#123;<span class="comment">//gap变化</span></span><br><span class="line">        <span class="keyword">for</span>(pos=gap; pos&lt;size; ++pos)&#123;<span class="comment">//直接插入排序</span></span><br><span class="line">            temp = data[pos];</span><br><span class="line">            <span class="keyword">for</span>(j=pos-gap; j&gt;=o &amp;&amp; data[j]&gt;temp; j-=gap)<span class="comment">//查找位置，从后往前找</span></span><br><span class="line">                data[j+gap] = data[j];</span><br><span class="line">            data[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不稳定 —— 大跨度的元素移动</p>
</li>
<li><p>不同gap，性能不同 </p>
</li>
<li><p>Shell —— O( n^(1.3) )</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>交换</p>
<ul>
<li><p>冒泡排序</p>
<blockquote>
<p>相邻元素关键字值比较，如果不满足排序要求(逆序)，则交换</p>
</blockquote>
<ul>
<li><p>每一趟排序，确定一个最值(位置在尾巴上)</p>
</li>
<li><p>不交换 —— 结束</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">Bubble_Sort</span>(<span class="title">T</span> <span class="title">data</span>[], <span class="title">int</span> <span class="title">size</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;size&amp;&amp;flag; ++i)&#123;</span><br><span class="line">        flag =<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span>(data[j+<span class="number">1</span>]&lt;data[j])&#123;</span><br><span class="line">            swap(data[j], data[j+<span class="number">1</span>]);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最少 —— O(n) —— 原序列有序，只一趟比较</p>
</li>
<li><p>最差 —— O(n^2) —— 正好逆序</p>
<ul>
<li>Σ( n-i )</li>
</ul>
</li>
</ul>
</li>
<li><p>快速排序，目前最快的内部排序 (分区交换排序)</p>
<ul>
<li><p>冒泡一次消除一个，快排一次消除多个逆序对</p>
<blockquote>
<ul>
<li>选择轴值</li>
<li>划分成两个子序列L&amp;R<ul>
<li>L中所有的记录 &lt; 轴值</li>
<li>R中所有的记录 &gt; 轴值</li>
</ul>
</li>
<li>递归到分组只有一个记录</li>
</ul>
</blockquote>
</li>
<li><p>轴值的选择</p>
<ul>
<li>第一个元素<ul>
<li>对于有序序列糟糕的划分，退化成O(n^2)</li>
</ul>
</li>
<li>随机<ul>
<li>很少能选到最差的，随机数的选择是比较花时间的</li>
</ul>
</li>
<li>取N个数，再取中值<ul>
<li>均匀划分</li>
</ul>
</li>
</ul>
</li>
<li><p>选的轴值相当于临时变量</p>
</li>
<li><p>一趟过程</p>
<blockquote>
<ul>
<li>两头low，high指针，交叉移动<ul>
<li>high 向左扫描，遇到比pivot小的停止，data[low] = data[high]</li>
<li>low   向右扫描，遇到比pivot大的停止,  data[high] = data[low]</li>
</ul>
</li>
<li>最后low == high —— 轴值元素位置</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">partition</span>(<span class="title">T</span> <span class="title">data</span>[], <span class="title">int</span> <span class="title">low</span>, <span class="title">int</span> <span class="title">high</span>)&#123;</span></span><br><span class="line">    	T temp = data[low];<span class="comment">//pivot</span></span><br><span class="line">    	<span class="keyword">while</span>(low!=high)&#123;<span class="comment">//一趟</span></span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=temp);<span class="comment">//high移动</span></span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">                data[low] = data[high];</span><br><span class="line">                ++low;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; data[low]&lt;=temp);<span class="comment">//low移动</span></span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">                data[high] = data[low];</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	data[low] = temp;</span><br><span class="line">    	<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(T data[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    pivot = partition(data, low, high);<span class="comment">//轴值位置</span></span><br><span class="line">    Quick_Sort(data, low, pivot<span class="number">-1</span>);</span><br><span class="line">    Quick_Sort(data, pivot+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一趟确定一个轴值到最终位置</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>不稳定  —— 大跨度的数据移动</li>
<li>S(n) = O( log2(n) )</li>
<li>时间<ul>
<li>平均 —— O(log2(n))  —— 最好的内部排序</li>
<li>最差 —— O(n^2)  —— 有序 的 <strong>比较次数</strong></li>
</ul>
</li>
<li>适用于，记录较多，且基本无序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>希尔排序第一趟后，猜gap<ul>
<li>结果应该是：gap组（每组 n/gap 个，组内有序）</li>
<li>组内直接插入排序</li>
</ul>
</li>
<li>每趟快速排序之后，至少完全确定一个 pivot 。</li>
<li>查找第 j 个元素<ul>
<li>利用快排思想</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>一个划分函数，返回轴值的索引 i 。<ul>
<li>i == j</li>
<li>i  &lt;  j  —— 往大的那边找</li>
<li>i  &gt;  j  —— 往小的那边找</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_jth</span><span class="params">(T data[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    i = partition(data,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            i = partition(data,i+<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;i)</span><br><span class="line">            i = partition(data,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T data[], <span class="keyword">int</span> <span class="number">1</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>, j=n, x=data[i].key;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; data[j].key&gt;=x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            data[i++] = data[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; data[i].key &lt;=x)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            data[j--] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>颜色排序（荷兰国旗）</li>
</ul>
<blockquote>
<ul>
<li>红R、白W、蓝B。三个指针ijk<strong>（j是工作指针，ik是标志指针）</strong><ul>
<li>初始位置<ul>
<li>i == j 在最前面</li>
<li>k在最后面</li>
</ul>
</li>
</ul>
</li>
<li>快排一趟，W从 i 开始。<ul>
<li>R  —— 交换到最前面 —— swap( data[j] , data[i] );  i++ ;  j++;</li>
<li>W —— 不管 —— j++ </li>
<li>B  ——  交换到最后    —— swap( data[j] , data[k]);  k–;</li>
</ul>
</li>
<li>j &gt; k 终止</li>
</ul>
</blockquote>
<ul>
<li>排序的主要操作 <ul>
<li>比较  +  移动</li>
</ul>
</li>
<li>稳不稳定 —— 指的是关键字相同的相对位置</li>
<li>希尔排序<ul>
<li>gap序列插入排序</li>
<li>最后直接插入排序</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>插入/交换排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构相关术语</title>
    <url>/2020/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构概念和术语"><a href="#数据结构概念和术语" class="headerlink" title="数据结构概念和术语"></a>数据结构概念和术语</h1><h2 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h2><ul>
<li><p>数据 data（广义） —— 所有能被计算机处理的，音频视频文本</p>
</li>
<li><p>数据元素 element—— <strong>“个体”</strong>，基本元素 / 元素、结点、记录、顶点</p>
<ul>
<li>一张图、一个学生记录、图的一个顶点</li>
<li>数据项的集合</li>
</ul>
</li>
<li><p>数据项 item —— 最小单位 —— 组成数据元素</p>
<ul>
<li>字段、域、属性</li>
<li>信息表中的列</li>
</ul>
</li>
<li><p>数据对象 object —— 具有相同性质的数据元素的集合 ——数据的一个子集</p>
<ul>
<li>整数集、 小写字符集合</li>
<li>某个专业全部学生</li>
</ul>
</li>
<li><p><strong>数据 —— 数据元素(行) —— 数据项（列）</strong></p>
<p>​ <strong>—— 数据对象（行的子集）</strong></p>
</li>
<li><p>数据结构 structure —— 特定关系的数据的存储和处理 —— 三要素</p>
<ul>
<li>逻辑结构<ul>
<li>线性 —— 一对一 （前驱和后继）<ul>
<li>线性表</li>
<li>栈/队列</li>
<li>字符串</li>
<li>数组和广义表</li>
</ul>
</li>
<li>非线性</li>
<li>树 —— 层次 —— 一对多 —— 根节点在上</li>
<li>图 —— 网状 —— 多对多</li>
<li>集合 —— 既不属于线性，又不属于非线性</li>
</ul>
</li>
<li>存储结构<ul>
<li>顺序 —— 数组（动态、静态）—— 一块连续的内存空间</li>
<li>链式 —— 不一定内存空间连续 —— 指针显式指出逻辑关系</li>
<li>索引 —— 索引表 ——“课本目录”</li>
<li>散列 —— 哈希 key mod p—— 哈希函数建立起关键字到唯一位置的关系</li>
</ul>
</li>
<li>运算实现<ul>
<li>增删改查</li>
</ul>
</li>
<li>ADT Abstract Data Structure<ul>
<li>逻辑结构 + 操作说明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-要点"><a href="#02-要点" class="headerlink" title="02 要点"></a>02 要点</h2><ul>
<li><p>数据元素之间的逻辑关系 —— 逻辑结构</p>
</li>
<li><p>DS，<strong>两种逻辑分类</strong></p>
<ul>
<li>两类：线性、非线性</li>
<li>四类：线性、树型、图型、集合</li>
</ul>
</li>
<li><p>属于逻辑结构 —— 有序表</p>
</li>
<li><p>顺序表、哈希表、单链表 —— 存储结构</p>
</li>
<li><p>DS —— 数据的<strong>逻辑结构 &amp; 存储结构</strong>以及他们之间的相互联系</p>
</li>
<li><p>集合结构 —— 元素之间没有任何逻辑关系</p>
<ul>
<li>线性 —— 一对一<strong>关系</strong></li>
<li>树型 —— 一对多</li>
<li>图型 —— 多对多</li>
</ul>
</li>
<li><p>非线性结构 —— 树、图</p>
<ul>
<li>前驱和后继结点 —— 一对多和多对多</li>
</ul>
</li>
<li><p>链式存储 —— 存放值 + 存放指针 —— 两部分内存</p>
</li>
<li><p>数据的最小单位 —— 数据项</p>
</li>
<li><p>基本单位 —— 数据元素</p>
</li>
<li><p>数据的逻辑结构和数据元素本身内容形式无关。</p>
</li>
<li><p>ADT 和 计算机内部表示、实现无关</p>
</li>
<li><p>存储结构 —— 顺序、链式、索引、散列</p>
</li>
<li><p>逻辑结构 —— 两类</p>
<ul>
<li>线性、非线性</li>
<li>线性、集合、树型、图型</li>
</ul>
</li>
<li><p>数据 —— 数据元素 —— 数据项</p>
<p>​ —— 数据对象</p>
</li>
<li><p>通讯录</p>
<ul>
<li>经常 插入删除 —— 链式</li>
<li>变化少 —— 顺序 —— 随机存取</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>定义</tag>
      </tags>
  </entry>
  <entry>
    <title>全体文档的树/图可视化</title>
    <url>/2020/07/25/%E6%96%87%E6%A1%A3%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="图可视化"><a href="#图可视化" class="headerlink" title="图可视化"></a>图可视化</h2><p>效果图：<br><img src="2020-07-29-20-46-51.png" alt=""></p>
<p>传统的“分类(Categories)+标签(Tags)”的二级模式虽足以应付大部分用户的需求，但本质上其还是需要用户对已有分类和标签有良好的组织，这对很多用户来说是根本做不到，因为我们往往缺的就是这种“纵览全局”的能力。</p>
<p>上-思路：<a href="https://www.cz5h.com/article/65a9.html" target="_blank" rel="noopener">https://www.cz5h.com/article/65a9.html</a><br>下-教程：<a href="https://www.cz5h.com/article/99a8.html" target="_blank" rel="noopener">https://www.cz5h.com/article/99a8.html</a><br>水平不够，看不懂。</p>
<p>Django3重写：<a href="https://github.com/sqlsec/Django-Hexo-Matery" target="_blank" rel="noopener">https://github.com/sqlsec/Django-Hexo-Matery</a></p>
<h2 id="标签云"><a href="#标签云" class="headerlink" title="标签云"></a>标签云</h2><p><a href="https://cungudafa.blog.csdn.net/article/details/104616500" target="_blank" rel="noopener">https://cungudafa.blog.csdn.net/article/details/104616500</a></p>
<p>themes\sakura\layout\tags.ejs</p>
<section class="outer">
  <% if (site.tags.length){ %>
    <h1 class="page-type-title"><%= __('tags') %></h1>
    <%- list_tags({show_count: theme.show_count}) %>
  <% } %>
</section>


]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2020/07/25/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>数组地址计算、矩阵压缩存储：特殊矩阵的公式（对称、三角、对角）。稀疏矩阵的存储（三元组、十字链表）</li>
<li>高频：压缩存储的概念和特殊矩阵的存储公式</li>
<li>0~5%</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>数组 —— 线性结构的推广</p>
</li>
<li><p>数组 —— <strong>下标和值的偶对的集合</strong>，（具有相同类型）</p>
</li>
<li><p>C语言，行主序，虚拟内存是一维的。</p>
</li>
<li><p>二维数组中</p>
<ul>
<li>a[ i ] 是第i行的行首地址</li>
</ul>
</li>
<li><p>N维数组可以看做是 元素是 n-1 维数组的向量</p>
<ul>
<li>向量可以是行向量</li>
<li>也可以是列向量</li>
</ul>
</li>
<li><p>N维数组中元素的个数。</p>
<ul>
<li>π （ 尾下标 - 首下标 + 1 ） == π（每一维度的元素个数）</li>
</ul>
</li>
<li><p>数组一般不做插入/删除，一般只，存取、修改。</p>
</li>
<li><p>存储方式</p>
<ul>
<li>行主序</li>
<li>列主序</li>
</ul>
</li>
<li><p><strong>计算元素地址（存储位置）</strong></p>
<ul>
<li>A[ i ] [ j ] ( c1&lt;i&lt;c2，d1&lt;j&lt;d2 )，每个数据占L个存储单元，首地址 —— LOC[c1] [c2]</li>
<li>LOC( i , j ) = LOC[c1] [c2] +  L*  [ (i-c1) * (d2-c2+1) +j-c2 ]</li>
<li><strong>从 1 开始时再 + 1</strong><ul>
<li>基地址 + 偏移地址</li>
<li>偏移地址 —— L *  [  前面有多少行*一行多少个元素 + 本列本元素前有多少个 ] —— L * i，j 之前存了多少</li>
<li>注意  索引/位序  从0开始</li>
</ul>
</li>
</ul>
</li>
<li><p>压缩存储矩阵（二维数组）</p>
</li>
<li><p>多个值相同的元素分配一个空间，值为0的不分配</p>
</li>
<li><p>两类矩阵</p>
<ul>
<li>特殊矩阵，非0元素有规律<ul>
<li>对称、三角、对角</li>
</ul>
</li>
<li>稀疏矩阵，非零元素少 (&lt;5%)，且无规律<ul>
<li>三元组，十字链表</li>
</ul>
</li>
</ul>
</li>
<li><p>对称矩阵</p>
<ul>
<li><p>a i j == a j i</p>
</li>
<li><p>N^2 个元素 —— n*(n+1)/2 个地址单位中</p>
</li>
<li><p>按行序将 主对角线+下/上三角存储到向量中</p>
</li>
<li><p>对应关系</p>
<ul>
<li><p>从0开始（+）</p>
<ul>
<li><p>下三角，i  &gt; = j</p>
<p>$$<br>\frac{i(i+1)}{2} + j<br>$$</p>
</li>
<li><p>上三角，i  &lt;  j</p>
<p>$$<br>\frac{j(j+1)}{2} + i<br>$$</p>
</li>
</ul>
</li>
<li><p>从1开始（-）</p>
<ul>
<li>分式里面＋变－</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三角矩阵</p>
<ul>
<li>下三角/上三角 元素为常数</li>
<li>对称矩阵多加一个存储单元<ul>
<li>最后一个存储单元<ul>
<li>0 —— $\frac{n(n+1)}{2}$</li>
<li>1 —— $\frac{n(n+1)}{2} + 1$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对角矩阵</p>
<ul>
<li>所有非零元素集中在主对角线为中心的带状区域中非零。（奇数条对角线）</li>
<li>三对角矩阵 一共  3n-2  个元素</li>
<li><strong>第一行和最后一行是2个，其余存3个</strong></li>
<li>1 —— 0<ul>
<li>主对角线上 i == j<ul>
<li>k == 3*（i-1）+1  ——  3 i</li>
</ul>
</li>
<li>左下 i == j+1<ul>
<li>k == 3*（i-1）      ——  3 i - 1</li>
</ul>
</li>
<li>右上 i = j-1<ul>
<li>k == 3*（i-1) + 2   —— 3 i + 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总公式 ——  *<em>k == 2( i - 1 ) + j   ——   k == 2i + j   *</em> </p>
<ul>
<li>k / 3 == i-1      ——      i ==   ( k+1 ) / 3</li>
<li>i j 关系由，对角线，右上，左下得到</li>
</ul>
</li>
</ul>
<ul>
<li><p>稀疏矩阵</p>
<ul>
<li><p>稀疏因子 —— t / (m*n)  &lt;= 0.05</p>
</li>
<li><p>结构</p>
<ul>
<li><p>三元组表    triple（row，col，val）数组</p>
<ul>
<li>矩阵的行、列（大小）、非零元素个数</li>
<li>转置 —— 行列互换，之后按照行序重新排列三元组表<ul>
<li>法2：遍历三元组表，找A中列为1的，存到B行为1</li>
<li>O(n*len)。</li>
</ul>
</li>
</ul>
</li>
<li><p>十字链表    TS</p>
<ul>
<li>行/列 的方向链接所有同一 行/列 的。</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3></li>
<li><p>常选特值带入验证。</p>
</li>
<li><p>注意下标从什么开始</p>
</li>
<li><p>查找矩阵中书否存在 key。—— O(m+n)</p>
<ul>
<li>双重循环 —— O(m*n)</li>
<li>矩阵有序<ul>
<li>和每一列的最值比较，确定行再遍历行</li>
<li>注意不要越界</li>
</ul>
</li>
</ul>
</li>
<li><p>k == 2 (i-1)  + j</p>
</li>
<li><p>三元组，在矩阵中非零元素的个数和位置在操作过程中变化不大时有效</p>
</li>
<li><p>数组是同类型的<strong>值和下标</strong>偶对的集合</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>散列/哈希表</title>
    <url>/2020/07/25/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>概念、构造散列函数、解决冲突</li>
<li>高频 ： 除留余数法、线性探测法</li>
<li>5%。但是期末必有一道计算题。大题。</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>基于关键码比较的检索</p>
<ul>
<li>顺序查找 —— ==  /  != —— O(n)</li>
<li>折半/树型 —— &gt; &lt; ==   —— O( log2(n) )</li>
</ul>
</li>
<li><p>hash/散列/杂凑—— 不基于比较，根据关键码的值，直接定地址 ——O(1)</p>
<ul>
<li>既可以检索，又可以存储</li>
</ul>
</li>
<li><p>冲突：不同的key，计算出相同的散列地址。</p>
<ul>
<li>同义词 ： 产生冲突的两个Key</li>
<li>PS：字符串数组 —— 二维数组 —— <ul>
<li>行：串</li>
<li>列：串中的字符</li>
</ul>
</li>
<li>负载（装填）因子：α = n / m <ul>
<li>散列表空间 m，填入结点数 n</li>
<li>越小 —— 冲突可能性越小</li>
</ul>
</li>
</ul>
</li>
<li><p>构造</p>
</li>
<li><p>直接定址：key或key的某个线性函数值（key / a*key+b）</p>
<ul>
<li>哈希地址取值范围和存储空间相同</li>
<li>不会产生冲突</li>
<li>但是栈用连续的地址空间，容易浪费，空间效率低</li>
</ul>
</li>
<li><p>折叠法：较长的管线自分割成几段位数相同的，（最后一段可以短一些）</p>
<p>   ​               然后叠加并舍去进位作为地址</p>
<ul>
<li>适用于位数多，并诶诶每一位的数字分布大致均匀</li>
</ul>
</li>
<li><p>移位叠加：将分割后的几部分低位对齐相加</p>
</li>
<li><p>间界叠加：从一端沿着分割来回折送，对齐相加</p>
<ul>
<li>例如：偶数段取反</li>
</ul>
</li>
<li><p>数值分析</p>
<ul>
<li>关键字的若干位或者其组合做地址</li>
<li>如：80个记录，关键字8位二进制——利用两位十进制数地址</li>
</ul>
</li>
<li><p>平方取中法</p>
<ul>
<li>关键码平方（平方数和每一位都有关），取中间几位</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>除留余数法 % ：</strong></p>
<ul>
<li><p>H(key) = key % p </p>
<ul>
<li><p>p&lt;=m的最大质数，</p>
</li>
<li><p>m 是哈希表表长</p>
</li>
<li><p>mod p 结果是 0 ~~ p-1</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>冲突</p>
</li>
<li><p>闭散列法（开放地址法） ——  冲突位置的前后寻找</p>
<ul>
<li><p>探测，寻找下一个空位</p>
<ul>
<li>Hi = ( H(key) +d_i )  %  m</li>
</ul>
</li>
<li><p>线性探测 —— di = 1,2,3，..，k，.，m-1</p>
<ul>
<li><p>散列表是一个循环表 %</p>
<p>| +        | 散列地址 | 0   | 1   | … |<br>| ——– | ——– | — | — |<br>| 关键字   |          |     |     |<br>| 比较次数 |          |     |     |</p>
</li>
<li><p>ASLsucc = 1/n * Σ ( 查找次数i * 个数 )</p>
</li>
<li><p>ASLloss  = 1/p * Σ ( 从点 i 开始要找到空位的<strong>比较次数</strong> )</p>
<ul>
<li>只看能被H(key)算出来的位置  % p —— 0 ~~ m-1</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>二次聚集，不同基地址元素争夺，同一个单元，使得ASL变大</li>
<li>所有都相同的时候，退化成顺序查找。</li>
</ul>
</li>
</ul>
</li>
<li><p>二次探测 —— di = k^2 —— k&lt;= m/2”↓”</p>
</li>
<li><p>双重散列法（随机数法）di = H2(key)</p>
</li>
</ul>
</li>
<li><p>开散列法（链地址法）</p>
<ul>
<li>散列地址相同的，存到一个<strong>单链表</strong>里面（所有元素都在链表上）。</li>
<li>不会产生冲突，</li>
<li>ASLsucc == 1/n * Σ ( 单链表中第 k 个结点 *  所有单链表含有的该层的结点个数 )</li>
<li>ASLloss  == 1/p * Σ ( 空的位置个数<em>1 + 所有链表第 k 层结点 * (k+1) ) —— *</em>参与的结点是 0 ~~ p-1**</li>
<li>元素个数不被限制</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>聚集(堆积)现象<strong>无法避免</strong>，只能<strong>减少</strong>。</li>
<li>ASL受堆积现象直接影响</li>
<li>k个关键字是同义词，存入hash表中，至少  k*(k+1)/2 == 1+2+3+…+k</li>
<li>区分 表长m 和 p</li>
<li>哈希表 —— <strong>地址、key、比较次数</strong></li>
<li>不存在好的坏的哈希函数 —— 只有合适的</li>
<li>删除时<ul>
<li>逻辑删除</li>
</ul>
</li>
<li>散列表 ASL 和结点个数无关</li>
<li>处理冲突的好坏影响ASL</li>
<li>查找失败时的概率 —— <strong>找p哈希函数</strong> 不找m表长</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/07/25/%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>概念特点，基本算法(进、出、取栈顶元素)</li>
<li>手工模拟(中缀转后缀、后缀表达式求值)</li>
<li>栈和队列常常 &lt;= 10%</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>栈和队列 —— 线性 —— 一对一关系 —— 操作受限</p>
</li>
<li><p>FILO原则(一头开口的管道，桶)</p>
<ul>
<li>栈顶 top</li>
<li>栈底 bottom</li>
<li>进栈/压栈 Push</li>
<li>退栈/弹栈 Pop</li>
</ul>
</li>
<li><p>栈溢出</p>
<ul>
<li>上溢出 —— 栈满之后还进栈</li>
<li>下溢出 —— 栈空之后还出栈</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><p>顺序栈</p>
<ul>
<li><p>位序小的是栈底。</p>
</li>
<li><p>空 —— <strong>top == -1</strong>, top==0 说明还有一个元素</p>
</li>
<li><p>入栈 —— ++top —— 先移动后存</p>
</li>
<li><p>出栈 —— top - - —— 先取出后出</p>
</li>
<li><p>栈底 bottom—— a_0       —— 第一个元素</p>
</li>
<li><p>栈顶 top      —— a_(n-1) —— <strong>最后一个元素</strong></p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">seqStack</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">        	T* data;	<span class="comment">//数组</span></span><br><span class="line">        	<span class="keyword">int</span> top;	<span class="comment">//栈顶元素下标</span></span><br><span class="line">        	<span class="keyword">int</span> maxSize;</span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        	seqStack(<span class="keyword">int</span> initSize = <span class="number">100</span>);</span><br><span class="line">            ~seqStack()&#123;<span class="keyword">delete</span> []data&#125;;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;top = <span class="number">-1</span>&#125;;<span class="comment">// 逻辑删除</span></span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> top+<span class="number">1</span>;&#125;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span></span>;	</span><br><span class="line">        		<span class="comment">// 常量引用，函数中这个值传入多少就一直是多少，不会改变</span></span><br><span class="line">        	<span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        	<span class="function">T <span class="title">getTop</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	seqStack&lt;T&gt;::seqStack(<span class="keyword">int</span> initSize = <span class="number">100</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(initSize &lt;= <span class="number">0</span>)	<span class="keyword">throw</span> BadSize();</span><br><span class="line">        data = <span class="keyword">new</span> T[initSize];</span><br><span class="line">        maxSize = initSize;</span><br><span class="line">        top = <span class="number">-1</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">void</span> seqStack&lt;T&gt;::push(<span class="keyword">const</span> T &amp;value)&#123;</span><br><span class="line">		<span class="keyword">if</span>(top == maxSize<span class="number">-1</span>)	<span class="comment">// 栈满 top == maxSize-1</span></span><br><span class="line">            <span class="keyword">throw</span> Full();</span><br><span class="line">        data[++top] = value;	<span class="comment">//进栈</span></span><br><span class="line">    &#125;</span><br><span class="line">	T seqStack&lt;T&gt;::pop()&#123;</span><br><span class="line">        <span class="keyword">if</span>(top  == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">throw</span> Empty();</span><br><span class="line">        <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;<span class="comment">// return是副产品，主要为了删除 —— STL中只是删除</span></span><br><span class="line">	T seqStack&lt;T&gt;::getTop()&#123;</span><br><span class="line">		<span class="keyword">if</span>(top == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">throw</span> Empty();</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;<span class="comment">// 只取不删</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>链栈</p>
<ul>
<li><p>不带头结点的单链表，头指针top指向首元元素</p>
</li>
<li><p>操作都在栈顶进行。</p>
</li>
<li><p>空 —— top == NULL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">linkStack</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>	<span class="comment">// 类中带结构体</span></span><br><span class="line">                T data;</span><br><span class="line">                Node* next;</span><br><span class="line">                Node(next = <span class="literal">NULL</span>);</span><br><span class="line">                Node(<span class="keyword">const</span> T &amp;value， Node *p = <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    data = value；next= p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        	Node* top;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            linkStack();</span><br><span class="line">            ~linkStack();</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> top == <span class="literal">NULL</span>;&#125;;<span class="comment">// 学习一下</span></span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span></span>;</span><br><span class="line">        	<span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        	<span class="function">T <span class="title">getTop</span><span class="params">()</span></span>;<span class="keyword">const</span>;</span><br><span class="line">    &#125;<span class="comment">//class</span></span><br><span class="line">	<span class="keyword">void</span> linkStack&lt;T&gt;::push(<span class="keyword">const</span> T &amp;value)&#123;</span><br><span class="line">        Node* p = <span class="keyword">new</span> Node();</span><br><span class="line">        p-&gt;data = value;</span><br><span class="line">        p-&gt;next = top; <span class="comment">//头插法</span></span><br><span class="line">        top = p;</span><br><span class="line">    &#125;</span><br><span class="line">	T linkStack&lt;T&gt;::pop()&#123;</span><br><span class="line">		<span class="keyword">if</span>(Empty())		<span class="keyword">throw</span> EmptyStack();</span><br><span class="line">        Node *p = top;		<span class="comment">// 为了delete ，p记录原top</span></span><br><span class="line">        T value = p-&gt;data;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;			</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">	T linkStack&lt;T&gt;::getTop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Empty())		<span class="keyword">throw</span> EmptyStack();</span><br><span class="line">        <span class="keyword">return</span> top-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">void</span> linKStack&lt;T&gt;::clear()&#123;</span><br><span class="line">		Node *p;</span><br><span class="line">        <span class="keyword">while</span>(top != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			p = top;</span><br><span class="line">            top = top-&gt;nex;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> linkStack&lt;T&gt;::size()&#123;</span><br><span class="line">		<span class="comment">// 遍历计数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结栈</p>
<ul>
<li>操作受限 —— FILO</li>
<li>顺序栈（存储密度大，实际常用，能快速定位，读取）和链栈</li>
</ul>
</li>
<li><p>应用</p>
</li>
<li><ol>
<li><p><strong>中缀求值</strong></p>
<ul>
<li>两个栈 —— optr运算符栈、 opnd操作数栈<ul>
<li>opnd 置空。optr压入’=’(作栈底元素)。</li>
<li>扫描存储中缀表达式的infix数组。读出字符infix[i]<ul>
<li>数字字符 —— 压入opnd</li>
<li>运算符    ——  则看优先级<ul>
<li>高于栈顶 —— 入栈optr</li>
<li>低于栈顶 —— optr出栈，opnd出栈两个数字，进行计算。结果压入opnd<ul>
<li><strong>优先级图片</strong></li>
<li>栈内外不同是因为优先顺序，向左/向右计算</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>例子 —— “12*( 6 - 3.5 )”<ul>
<li>optr   :   =，*，（，-，）</li>
<li>opnd :   12，6，3.5，<ul>
<li>） —— 开始弹栈。</li>
<li>’-‘ —— 先出来的是减数，后出来的是被减数。</li>
<li>’*‘ —— 先出乘数，后出被乘数</li>
<li>=  —— 不停弹栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li><p><strong>中缀转后缀。</strong></p>
<ul>
<li>后缀优点<ul>
<li>无括号</li>
<li>不比考虑优先级</li>
<li>运算符放在运算对象后面。按照运算符出现的顺序进行计算。</li>
</ul>
</li>
<li>手工模拟<ul>
<li>中缀放在infix[]。后缀放在postfix[]。(字符数组)</li>
<li>设置optr栈</li>
<li>infix[i] ==<ul>
<li>( —— 压入 optr。栈外优先级最高，入栈之后变小。</li>
<li>操作数 —— 送入postfix[]</li>
<li>运算符 ，相较于栈顶元素运算级别<ul>
<li><strong>高 —— 入栈</strong></li>
<li><strong>低 —— 栈顶退栈</strong>，进入postfix，再与新的栈顶比较</li>
</ul>
</li>
<li>） —— 栈中元素一次送入postfix。知道碰到“（”，消去一对括号。</li>
<li>=  ——  开始退栈，并直接存入postfix，直至栈空。</li>
</ul>
</li>
<li>最后在postfix中存入 ‘\0’。表示结束标志</li>
<li>PS：数字之间用空格分隔。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>后缀表达式求值<pre><code>+ 扫描
     + 数字存入opnd
     + 字符 ——栈中弹出两个数，先出的在右边</code></pre></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>技巧中缀转后缀的快捷方法</strong>（未使用栈）</p>
<ul>
<li>加括号 —— 所有能加上括号的地方</li>
<li>移动运算符 —— 移到相应的括号后边</li>
<li>删括号 </li>
</ul>
</li>
<li><p>栈和递归</p>
<ul>
<li>系统内部，函数调用由<strong>递归工作栈</strong>实现。若程序员可以操纵这个栈，那么就可以消除递归</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>问题的定义是递归的 ——阶乘</li>
<li>问题的结构是递归的 ——链表</li>
<li>问题的解法是递归的 ——汉诺塔</li>
</ul>
</li>
<li><p>汉诺塔 hanoi。n个盘子，最少移动 2^(n-1)次 —— <strong>利用归纳法</strong></p>
<ul>
<li>　　　　1）   把n-1个盘子由A 移到 B；</li>
</ul>
</li>
</ul>
</li>
<li><p>2）   把第n个盘子由 A移到 C；</p>
<ul>
<li><p>3）   把n-1个盘子由B 移到 C；</p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n,from_,buffer,to)</span>:</span>
    <span class="keyword">if</span> n==<span class="number">1</span>:
        print(<span class="string">'Move'</span>,n,<span class="string">'from'</span>,from_,<span class="string">'to'</span>,to)
    <span class="keyword">else</span>:
        move(n<span class="number">-1</span>,from_,to,buffer)
        move(n,from_,buffer,to)
        move(n<span class="number">-1</span>,buffer,from_,to)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">int hannuota(int n,string a,string b,string c)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;只有一个盘子的情况下直接将第一个塔上的盘子移动到第三个塔</span><br><span class="line">        printf(&quot;塔%s------&gt;塔%s\n&quot;,a.c_str(),c.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        &#x2F;&#x2F;1.先将第一个塔的n-1个盘子全部通过第三个塔移动到第二个塔上</span><br><span class="line">        hannuota(n-1,a, c, b);</span><br><span class="line">        &#x2F;&#x2F;2.再将剩下的一个盘子移动到第三个塔上</span><br><span class="line">        printf(&quot;塔%s------&gt;塔%s\n&quot;,a.c_str(),c.c_str());</span><br><span class="line">        &#x2F;&#x2F;3.最后将第二个塔上的盘子通过第一个塔移动到第三个塔上</span><br><span class="line">        hannuota(n-1, b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>FILO —— 输入次序为 <code>123PA</code>，问经栈后所有可能结果</p>
<ul>
<li>A开头 —— P321绑定<ul>
<li>AP123</li>
</ul>
</li>
<li>P开头的 —— 123已经入栈  —— <strong>321 的相对关系已经定了</strong><ul>
<li>P X  3  X  2   X   1    X  —— A没有入栈，选一个 X位置</li>
<li>P321A、P32A1、P3A21、PA321、</li>
</ul>
</li>
</ul>
</li>
<li><p>入栈序列 1234，问出栈序列    <strong>同上</strong></p>
<ul>
<li>3 开头的有四种可能</li>
</ul>
</li>
<li><p>abcde进栈，可边出边进，以d开头的可能是 ？。<strong>同上</strong></p>
</li>
<li><p>abcdef 依次入栈，可以交替进出，但是不能连续出三次。</p>
<ul>
<li>不可能是有符合入栈次序的连续的三个及以上的。</li>
</ul>
</li>
<li><p><strong>错了一次</strong>123…n入栈，出栈 p1,p2,p3,…pn。P2是3的时候，p3有几种可能？</p>
<ul>
<li>n-1种<ul>
<li>4~n好想</li>
<li>p1 == 1 —— 可以是2</li>
<li>p1 == 2 —— 可以是1</li>
</ul>
</li>
</ul>
</li>
<li><p>中缀转后缀</p>
<ul>
<li>技巧 —— 选择题</li>
</ul>
</li>
<li><p>中缀转后缀，栈至少多大/同时保存在栈中的操作符最大个数</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000017151354" target="_blank" rel="noopener">函数栈的实现原理</a>出现在CSAPP</p>
</li>
<li><p>递归算法的组成</p>
<ul>
<li>终止条件/递归出口</li>
<li>递归部分</li>
</ul>
</li>
<li><p>求解排列组合数 —— size个数中取出k个数的所有排列组合</p>
<ul>
<li><p><a href="https://blog.csdn.net/sjpz0124/article/details/47702835" target="_blank" rel="noopener">利用公式C(n, k) = C(n - 1, k) + C(n - 1, k - 1)</a> N中选k有多少种！</p>
</li>
<li><p><a href="https://www.jianshu.com/p/718a5ac26238" target="_blank" rel="noopener">小朋友学算法：数论</a>再不努力，连小学生也比不上。</p>
</li>
<li><p>本题</p>
<ul>
<li>包含A[0]，1~size-1中取 k-1个</li>
<li>不包含A[0]，1~size-1中取k个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[size],B[size];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> kk)</span><span class="comment">// kk待选取的元素个数</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// A数组从i开始，B数组从j开始，要选取kk个元素的所有组合</span></span><br><span class="line">    <span class="keyword">if</span>(kk == <span class="number">0</span>)&#123;				<span class="comment">// 选完了k个</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)&#123;  <span class="comment">// 输出B数组中的，选出来的k个数字</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;B[i]&lt;&lt;<span class="string">"  "</span>;	        </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i+kk<span class="number">-1</span>&lt;size<span class="number">-1</span>)&#123;		<span class="comment">// kk &gt; 0 ,还没选完</span></span><br><span class="line">			B[j++] = A[i];</span><br><span class="line">        	 function(i+<span class="number">1</span>,j,kk<span class="number">-1</span>);<span class="comment">//j ——选取的数包括A[i]</span></span><br><span class="line">        	 function(i+<span class="number">1</span>,j<span class="number">-1</span>,kk);<span class="comment">//j-1 —— 选取的数不包含A[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>倒序第i个元素是，正序 n-i+1个元素</p>
</li>
<li><p>两头栈 —— 栈满 top[1] + top[2] == size</p>
</li>
<li><p>知道入栈队列，求出栈队列</p>
<ul>
<li>按谁开头来进行分类写</li>
<li>排列组合 == 栈可能 + 栈不可能</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2020/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>源点到其余各点 —— Dijkstra</li>
<li>每一对顶点之间 —— Floyd</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>Dijkstra，源点到其余点</p>
<ul>
<li>给定源点，权值非负数，有负数失效</li>
<li>按路径长度递增次序产生到个顶点最短路径的贪心算法</li>
</ul>
</li>
<li><p>思想</p>
<blockquote>
<ul>
<li>V分成两组<ul>
<li>S：已经求出最短路径的顶点集合</li>
<li>V-S：未求出的，将 V-S 中顶点按最短路径递增的次序加入到S</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>手工模拟</p>
<table>
<thead>
<tr>
<th>迭代</th>
<th>集合S</th>
<th>选择顶点</th>
<th>dist</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>初值</td>
<td>起点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>起点进入S</li>
<li>更新起点到邻接点的dist（dist初始化为∞）<ul>
<li>新的dist更小时才更新</li>
<li>dist[ new ] = dist[该点]  +  边权值</li>
<li>起点的dist  == 0</li>
</ul>
</li>
<li>选择最小的dist，将该点加入S，并以该点为起点</li>
</ul>
</li>
<li><p>邻接矩阵 /  邻接表 —— T(n) == O(n^2)</p>
<ul>
<li>关键在于更新和查询 dist[n]  —— n^2</li>
<li>矩阵 —— n^2</li>
<li>表     —— n+e</li>
</ul>
</li>
<li><p>是否支持负权边</p>
<ul>
<li>贪心算法，取最小进来之后，不会返回去计算 —— 不支持</li>
</ul>
</li>
</ul>
<ul>
<li><p>All-pairs shirtest paths</p>
<ul>
<li>重复Dijkstra  n 次 —— O(n^3)</li>
</ul>
</li>
<li><p>Floyd ，</p>
<ul>
<li>典型的动态规划算法，自底向上求解子问题的解，然后由这些子问题的解得到原问题的解</li>
<li>同 O(n^3)，但是形式简单。</li>
</ul>
</li>
<li><p>算法步骤:</p>
<blockquote>
<ul>
<li>初始化dist矩阵[n] [n]<ul>
<li>没有弧 —— ∞ </li>
<li>i == j    —— dist[i] [j] == 0</li>
<li>有弧，dist[i] [j] == weight( vi , vj )</li>
</ul>
</li>
<li>对每一个顶点 <strong>k</strong>，如果，<u><strong>dist[i] [k] + dist[k] [j] &lt; dist[i] [j]</strong></u><ul>
<li>表明i–k–j 的零更短 —— 更新 dist[i] [j] = dist[i] [k] + dist[k] [j] </li>
</ul>
</li>
<li>n 个顶点依次加入每一对顶点进行探测</li>
</ul>
</blockquote>
</li>
<li><p>位置的理解</p>
<ul>
<li>在一个三重循环里面的一个双重循环 —— i，j 不定、k是定值。<ul>
<li>[i] [k] —— 第k列上的一个值</li>
<li>[k] [j] —— 第k行上的一个值</li>
<li>[i] [j]  —— i 行 j 列</li>
</ul>
</li>
<li>例如 ：  3 * 3矩阵，试探V0时<ul>
<li>V0，所在的行和列，以及主对角线不看</li>
<li>看到 1,2 和 2,1</li>
<li><strong><u>1—-2 变成 1–0–2</u></strong>，看看是不是变小可，要不要跟新 i j</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>,<span class="title">class</span> <span class="title">EdgeType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">adhMatrix</span>&lt;VertexType,EdgeType&gt;:</span>:floyd()<span class="keyword">const</span>&#123;</span><br><span class="line">        EdgeType **dist = <span class="keyword">new</span> EdgeType*[verNum];	<span class="comment">// Attention</span></span><br><span class="line">        <span class="keyword">int</span> i,j,k;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)&#123;</span><br><span class="line">            dist[i] = <span class="keyword">new</span> EdgeType[verNum];<span class="comment">//Attention 二维数组的申请</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;verNum; ++i)&#123;	<span class="comment">// 初始化</span></span><br><span class="line">                dist[i][j] = (i==j)? <span class="number">0</span>:edges[i][j];<span class="comment">//对脚线 // 邻接矩阵</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新 dist矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;verNum; ++k)</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;verNum; ++i)</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;verNum; ++j)</span><br><span class="line">                    <span class="keyword">if</span>(dist[i][k]+dist[k][j] &lt; dist[i][j])&#123;</span><br><span class="line">                        dist[i][j] = dist[i][k]+dist[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>Dijkstra<ul>
<li>起点，利用其邻接点，更新dist</li>
<li>选择dist最小的作新结点</li>
<li>利用其临界点更新 dist。不断重复</li>
</ul>
</li>
<li>给定n个村庄的道路，问在哪健医院，使得医院到最远村庄的距离最近<ul>
<li>FLoyd —— dist 各村庄之间最短的<ul>
<li>每一行的最大值<ul>
<li>其中的最小值 —— 建设位置</li>
</ul>
</li>
</ul>
</li>
<li>dist的含义<ul>
<li>i 行 —— 结点 i 到结点 j 的一系列最短距离</li>
</ul>
</li>
</ul>
</li>
<li>Dijkstra —— 不能处理负权值<ul>
<li>某点到其他点的最短距离</li>
</ul>
</li>
<li>Floyd     —— 允许弧的权值为负，但是不能有负权值回路<ul>
<li>每对顶点之间的最短距离</li>
</ul>
</li>
<li>邻接矩阵<ul>
<li>VerNum * VerNum</li>
<li>1   /   0   /   权值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/07/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>最小生成树、<strong>Prim、Kruskal</strong></li>
<li>选择判断填空应用、客观题为主</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>最小生成树 ： 加权连通图，各边权值之和最小的生成树（可能不唯一、权值之和唯一）</p>
<ul>
<li>城市和公路</li>
</ul>
</li>
<li><p>MST性质</p>
<ul>
<li>G加权连通图，U是顶点集V的非空子集。若（u ， v）是一条具有最小权值的边，其中  u ∈U，v∈（V-U）则必存在一棵包含（u，v）的最小生成树</li>
</ul>
</li>
<li><p>Prim，基于顶点的贪心算法。</p>
<blockquote>
<ul>
<li>初始化最小生成树。（只一个顶点）</li>
<li>找代价最小的边（u,v）（符合MST性质）<ul>
<li>边入TE，点入U</li>
</ul>
</li>
<li>重复至U=V。<ul>
<li>此时，必定 n-1 条边，</li>
<li>最小生成树（U,TE）<ul>
<li>TE存的是边的编号</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>边可以用三元组表示</li>
</ul>
</li>
<li><p>Kruskal，使用贪心准则，</p>
<ul>
<li><p>从剩下的边中选择最优最小值，且不会产生环的边加入边集</p>
<blockquote>
<ul>
<li>n 个顶点，n个连通分量。 T = &lt; V,{ } &gt;</li>
<li>E 中选取代价最小的，加入（不可生成环）<ul>
<li>依附于两个不同的连通分支，否则舍去</li>
</ul>
</li>
<li>知道所有顶点，都在一个连通分量中</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>prime</p>
<ul>
<li>基于顶点的贪心算法，“加点法”，<strong>适合稠密图</strong>。</li>
</ul>
</li>
<li><p>Kruskal</p>
<ul>
<li>基于边的贪心算法，“加边法”，<strong>适合稀疏图</strong></li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li><p>MST（最小生成树）是不是唯一的？</p>
<ul>
<li>充分条件：<ul>
<li>任何一个环中不存在相同值的边 </li>
<li>所有边的权值都不同</li>
<li>U和V-U 之间，任何时刻不存在权值相同的</li>
</ul>
</li>
</ul>
</li>
<li><p>最小生成树</p>
<ul>
<li>不能有环  —— 不是所有最短的</li>
<li>代价唯一。</li>
<li>不是所有权值小的边都在最小生成树中</li>
</ul>
</li>
<li><p>连通网最小生成树</p>
<ul>
<li>Prim（稠密）  &amp;  Kruskal（稀疏），两种贪心法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>树和二叉树</title>
    <url>/2020/07/25/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>树的<strong>性质</strong></li>
<li>选择、判断、填空。<strong>手工模拟</strong></li>
<li>大于等于 20% </li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>树Tree。（自上而下生长）</p>
<ul>
<li>有且只有一个根节点（第一层）。<ul>
<li>根节点无前驱。（在最上）</li>
<li>叶子结点无后继。（在最下）</li>
</ul>
</li>
<li>除根节点外的其他节点被分成m个互不相交的有限集合。每个集合都是一棵树/子树 (递归)。</li>
<li>儿子节点 —— 直接后继</li>
<li>双亲        —— 直接前驱</li>
</ul>
</li>
<li><p>有序树ordered</p>
<ul>
<li>从左到右，结点位置固定，不能互换位置。</li>
<li>当某结点的左孩子删掉，右边的会补位到左边(族谱中，大儿子夭折，二儿子变大儿子)</li>
</ul>
</li>
<li><p>二叉树 binary</p>
<ul>
<li>度为2的有序树   !=    二叉树   （二叉树，不会因删除结点而产生的变化）</li>
</ul>
</li>
<li><p>满二叉树 full</p>
<ul>
<li>每一层都达到了最大值结点个数</li>
<li>高度k  —— 结点共  2^(k) - 1</li>
<li>层数k  —— 结点     2^(k-1) </li>
</ul>
</li>
<li><p>完全二叉树</p>
<ul>
<li><strong>结点编号连续</strong>，且与满二叉树一一对应。</li>
<li><strong>前 k-1层是满的，k层可满可不满，</strong></li>
<li>叶子出现在层次最大的两层</li>
<li>左分支层次为l，右分支层次 l 或 l-1。  —— 没有左孩子一定没有左孩子</li>
</ul>
</li>
<li><p>完全二叉树不是满二叉树，满二叉树是完全二叉树。</p>
</li>
<li><p>编号和父子关系</p>
<ul>
<li>节点 i ，左孩子  2i。 右孩子   2i+1。双亲 i/2 （向下取整）</li>
</ul>
</li>
<li><p><strong>性质</strong>  —— 重点中的重点。</p>
<ul>
<li>层次 i  —— 2^(i-1)个结点  —— 每过一层，满二叉树每一层的结点数翻倍</li>
<li>高度 k —— 最多有 2^k -1 个结点</li>
<li>叶节点数 == 度为2的结点数 + 1  —— n0 == n2 + 1<ul>
<li>n = n0 + n1 +n2；</li>
<li>度B == n-1 == n1 + 2*n2</li>
</ul>
</li>
<li>n个结点  ——  高度  log2（n+1）  ”向上取整“   <strong>或者</strong>    log2（n）“向下取整” +1<ul>
<li>高度为k的结点数，最多 2^k - 1 个结点，最少2^(k-1) -1 +1  —— 2^(k-1)个结点</li>
<li>2^(k-1)  &lt;= 结点数n  &lt;= 2^(k) - 1    —— 2^(k-1) + 1  &lt;= 结点数n + 1 &lt;= 2^(k) </li>
</ul>
</li>
<li>n个结点完全二叉树，编号。<ul>
<li>i = 1  ——  根节点</li>
<li>i &gt; 1  ——  双亲节点  n/2”↓”</li>
<li>2i &lt;= n  ——  i的左孩子的编号是2i，否则无左孩子</li>
<li>2i+1 &lt;= n  ——  则 i 的右孩子的编号是  2i+1，否则没有右孩子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>一棵深度为 k 的完全二叉树，<ul>
<li>最少：2^(k-1)个</li>
<li>最多：2^k - 1个</li>
</ul>
</li>
<li>一棵完全二叉树的第 6 层。有 8 个叶子结点。则最多结点数<ul>
<li>前k层是满二叉树</li>
<li>最多结点  ——  第六层是倒数第二层<ul>
<li>第七层全叶子结点，数目是第六层非叶子结点的两倍</li>
</ul>
</li>
<li>最少结点  ——  第六层是导师第一层</li>
</ul>
</li>
<li>n 个结点，并且高度为 n 的二叉树。 ——  <strong>单支树</strong><ul>
<li>只有根节点不区分左右，其他都要分左右   ——   单支树数目：2^(n-1)</li>
</ul>
</li>
<li>有1025个结点，高度范围<ul>
<li>最大 ：单支树                —— 高度 == 结点数 </li>
<li>最少 ： 满/完全二叉树  —— 高低 == log2(n+1)“↑”</li>
</ul>
</li>
<li>完全二叉树，有768个结点，则该二叉树中叶子结点的个数是<ul>
<li>n0 == n2 + 1 、n0 + n2 = 2n0 -1 (奇数)</li>
<li><strong>结点总数</strong>（n0 + n1 + n2 == 2*n0 -1 + n1）是偶数 —— n1 == 1</li>
<li><strong>在完全二叉树中，度为 1 的结点 n1 ，为0，或者为1</strong></li>
<li><strong>叶子结点n0 = n/2”↑”</strong></li>
</ul>
</li>
<li>也可二叉树的度可以   &lt; 2 ，但是不能  &gt;2</li>
<li>补充：<a href="https://blog.csdn.net/Hackbuteer1/article/details/7450250" target="_blank" rel="noopener">卡特兰数 Catalan</a><ul>
<li>n 个结点的所有二叉树的形状总数</li>
<li>n 个结点的合法出栈序列个数</li>
</ul>
</li>
</ul>
<p>![image-20200525090140991](C:\Users\gao xiwang\AppData\Roaming\Typora\typora-user-images\image-20200525090140991.png)</p>
<ul>
<li>根节点的度 == 0</li>
<li>k叉树<ul>
<li>n = n0 +n1 +n2…..</li>
<li>B = 0    +1    +2    +3   +4 ….. +n</li>
<li>B = n   -    1</li>
<li>叶子结点 ： n0 = 1 X n2 + 2 X n3  + (k-1)nk  + 1</li>
</ul>
</li>
<li>有 n 个结点的满二叉树 —— n为奇数<ul>
<li>没有度为 1 的结点</li>
<li>分支结点(非叶子结点)，(n-1)/2或n/2“↓”。</li>
<li>叶子结点 ： (n+1)/2</li>
<li>高度 ： log2(n+1)”↑”   /   log2(n)”↓” + 1 </li>
</ul>
</li>
<li>n 个结点，完全二叉树的最大的分支结点<ul>
<li>编号最大的分支结点  ——  n/2“↓”</li>
</ul>
</li>
<li>二叉树不是有序树，要明确区分左右。</li>
<li>n个结点的树，边数 —— n - 1</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>定义</tag>
      </tags>
  </entry>
  <entry>
    <title>碰到的术语们</title>
    <url>/2020/07/25/%E7%A2%B0%E5%88%B0%E7%9A%84%E6%9C%AF%E8%AF%AD%E4%BB%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MinGW是啥"><a href="#MinGW是啥" class="headerlink" title="MinGW是啥"></a>MinGW是啥</h2><p><a href="https://blog.csdn.net/jpcfei/article/details/6428613" target="_blank" rel="noopener">https://blog.csdn.net/jpcfei/article/details/6428613</a></p>
<p> MinGW 提供了一套简单方便的Windows下的基于GCC 程序开发环境。</p>
<h2 id="JSON数据交换格式是啥"><a href="#JSON数据交换格式是啥" class="headerlink" title="JSON数据交换格式是啥"></a>JSON数据交换格式是啥</h2><p>son是一种数据交换格式，<del>大部分是JavaScript的子集</del>现在变成完全子集了。在这里就是用作<strong>配置</strong>文件。VSC和各个扩展会读取json中的条目，来决定某些功能和行为。</p>
<p>这么多条目哪里来的呢？这其实和API差不多。扩展开发者会把允许修改的选项“告诉”VSC，各个扩展的安装页面都有写。作为使用者，输入的时候VSC会提示你哪些是可用的，所以其实很容易写。</p>
<p>为什么要往json里写这么多的东西？因为VSC本身并没有对C语言特别优待，对其他许多语言也一样。而且最关键的编译命令和VSC是没有关系的，这就是上面提到过的编辑器和编译器的事。VSC不负责、无法、不能编译C语言。</p>
<p>以$开头的是VSC预定义的变量，具体参见：<a href="https://link.zhihu.com/?target=https%3A//code.visualstudio.com/docs/editor/variables-reference">Variables Reference</a>。比如$file在实际运行时会替换成当前打开的文件名。</p>
<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><p>加断点在列号前面点一下就行，右键可以加条件断点。如果想从一开始就停下来，可以加在main函数那里，或者<em>launch.json</em>中有个设置。开始调试后，按f11可以一步一步进行，箭头所指的那行代码就是<strong>下一步要运行的代码</strong>；f5是一直运行到下一个断点，右键某一行代码可以选择一直运行到指定的那一行。</p>
<p>左边有个调试栏，可以看到变量的值，自动栏没有的可以手动添加：在代码里选中要监视的表达式，点右键有选项可以直接添加到Watch里，复杂的才需要手打。把鼠标放到变量上可以看到变量的值，但是只能识别简单的表达式。栈帧对于观察递归很有用。栈溢出和段错误时还可以抓取“异常”，自动跳转到出错的行。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>我的电脑-高级设置–环境变量–path<br>设置之后可以再cmd界面中运行添加的XXX.exe<br>大多要是添加 “XX”或“XX/bin”路径</p>
]]></content>
      <categories>
        <category>计算机基本概念</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title>应用题高频考点</title>
    <url>/2020/07/25/%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="01-树"><a href="#01-树" class="headerlink" title="01 树"></a>01 树</h2><h3 id="前中后层次遍历"><a href="#前中后层次遍历" class="headerlink" title="前中后层次遍历"></a>前中后层次遍历</h3><ul>
<li><p>子树，NLR、LNR、LRN的领会（递归）</p>
</li>
<li><p>有时候把左子树抽象成左孩子，直至叶子变N</p>
</li>
<li><p>前序 NLR，先最左边一道，再是从下到上的子树，再是右边，从上到下的子树</p>
</li>
<li><p>中序 LNR，第一个是最左边的结点，后面拐入右子树（由下到上），</p>
</li>
<li><p>后序 LRN，第一个是</p>
</li>
<li><p>层次遍历 —— 编号序列</p>
</li>
</ul>
<h3 id="中序-前-后序-，得到树"><a href="#中序-前-后序-，得到树" class="headerlink" title="中序 + 前/后序 ，得到树"></a>中序 + 前/后序 ，得到树</h3><ul>
<li>根节点位置特别注意，中序序列，根划分子树。前/后序容易找根。</li>
<li>不断用“根”分割左右子树集合，直至叶子变N</li>
</ul>
<h3 id="森林转换二叉树"><a href="#森林转换二叉树" class="headerlink" title="森林转换二叉树"></a>森林转换二叉树</h3><ul>
<li>连线，<ul>
<li>根节点兄弟之间。</li>
<li>森林子树的同层兄弟之间</li>
</ul>
</li>
<li>删线，<ul>
<li>删除根节点和非First Child之间（左孩子右兄弟表示法）</li>
<li>专门看那些不是一个孩子的结点。</li>
<li>有孩子没有兄弟的结点就只剩下左子树</li>
</ul>
</li>
<li>旋转，顺时针 45 °</li>
</ul>
<h3 id="二叉树转换成森林"><a href="#二叉树转换成森林" class="headerlink" title="二叉树转换成森林"></a>二叉树转换成森林</h3><ul>
<li>删线，删除根节点和右孩子的连线</li>
<li>连线，连接根节点和他的非first Child结点<ul>
<li>first child的右兄弟们</li>
</ul>
</li>
<li>旋转</li>
<li>注意<ul>
<li>森林的第一棵树：根节点 + 左子树</li>
<li>右子树是别的树们。（递归定义）</li>
<li>右边那一道上全是森林的子树根节点</li>
</ul>
</li>
</ul>
<h3 id="后序遍历森林"><a href="#后序遍历森林" class="headerlink" title="后序遍历森林"></a>后序遍历森林</h3><ul>
<li>相当于<strong>中序遍历二叉树</strong></li>
<li>相当于<strong>挨个后序遍历森林的子树</strong></li>
</ul>
<h3 id="前序遍历森林"><a href="#前序遍历森林" class="headerlink" title="前序遍历森林"></a>前序遍历森林</h3><ul>
<li><strong>前序遍历二叉树</strong></li>
<li>前序遍历森林的子树</li>
</ul>
<h3 id="先根-后跟森林，画出森林"><a href="#先根-后跟森林，画出森林" class="headerlink" title="先根 + 后跟森林，画出森林"></a>先根 + 后跟森林，画出森林</h3><ul>
<li>先画森林二叉树<ul>
<li>先根森林 —— 先根二叉树</li>
<li>后跟森林 —— 中根二叉树</li>
</ul>
</li>
<li>先根找根，中根分割子树，直至叶子变根节点</li>
<li>森林二叉树拆解成森林子树二叉树<ul>
<li>删线(所有右枝)—— 加线(根到孩子) —— 旋转</li>
</ul>
</li>
</ul>
<h3 id="画Huffman-树、"><a href="#画Huffman-树、" class="headerlink" title="画Huffman 树、"></a>画Huffman 树、</h3><ul>
<li><p>树型不唯一，WPL唯一</p>
</li>
<li><p>频率作权值，</p>
<ul>
<li>有时候频率是整数、有时小数(累加和==1)</li>
</ul>
</li>
<li><p>挑最小的两个作孩子合并成新的单位</p>
<ul>
<li>左小右大 —— 老师判题方便</li>
</ul>
</li>
<li><p>挑最小的两个的时候，容易<strong>脑抽</strong></p>
</li>
<li><p>大的近，小的远</p>
</li>
</ul>
<h3 id="写Huffman编码、"><a href="#写Huffman编码、" class="headerlink" title="写Huffman编码、"></a>写Huffman编码、</h3><ul>
<li>左分支 —— 0</li>
<li>右分支 —— 1</li>
<li>从根到叶子读取、从上到下</li>
</ul>
<h3 id="求树的WPL"><a href="#求树的WPL" class="headerlink" title="求树的WPL"></a>求树的WPL</h3><ul>
<li>Σ 叶子结点WPL</li>
<li>WPL = 权值 *  路径长度</li>
<li>路径长度 —— 在第几层</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li><strong>完全二叉树</strong>  +  双亲 &lt; 两个孩子  或者  双亲 &gt; 两个孩子</li>
<li>实现优先级队列</li>
</ul>
<h4 id="插入堆"><a href="#插入堆" class="headerlink" title="插入堆"></a>插入堆</h4><ul>
<li>叶子处，最后一层找</li>
<li><strong>从下向上调整</strong>。</li>
</ul>
<h4 id="删除堆元素"><a href="#删除堆元素" class="headerlink" title="删除堆元素"></a>删除堆元素</h4><ul>
<li>向下调整</li>
<li>删除树根<ul>
<li>和尾巴交换，再调整（由根向下）</li>
<li>再删去最后一个位置（此时存的是原根）</li>
</ul>
</li>
</ul>
<h4 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h4><ul>
<li>序列 写成完全二叉树</li>
<li>再调整<ul>
<li>从最后一个非叶子结点开始，向<strong>前</strong>调整</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>二叉树遍历</li>
<li>遍历序列画树</li>
<li>树和森林转换</li>
<li>森林的遍历</li>
<li>画森林</li>
<li>Huffman树和编码和WPL</li>
<li>Heap</li>
</ul>
<h2 id="02-集合结构"><a href="#02-集合结构" class="headerlink" title="02 集合结构"></a>02 集合结构</h2><p>查找、排序、散列表</p>
<h3 id="折半查找的判定树"><a href="#折半查找的判定树" class="headerlink" title="折半查找的判定树"></a>折半查找的判定树</h3><ul>
<li>有序表 + 顺序结构</li>
</ul>
<h4 id="画判定树"><a href="#画判定树" class="headerlink" title="画判定树"></a>画判定树</h4><ul>
<li>mid —— root 来分割左右子树集合，直到叶子</li>
<li><strong>注意根节点是mid对应的</strong></li>
</ul>
<h4 id="平均查找长度"><a href="#平均查找长度" class="headerlink" title="平均查找长度"></a>平均查找长度</h4><ul>
<li>成功<ul>
<li>ASL_success == $\frac{1}{结点个数}<em>\sum(层数</em>每层有多少个结点)$</li>
</ul>
</li>
<li>失败<ul>
<li>ASL_loss        ==$\frac{1}{外部结点个数}<em>\sum{[(层数-1)</em>该层的外部结点个数]}$</li>
<li>外部结点 —— 全是叶子结点 n0<ul>
<li>n0 = n2 + 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查找路径"><a href="#查找路径" class="headerlink" title="查找路径"></a>查找路径</h4><ul>
<li>单支树</li>
<li>mid —— root</li>
</ul>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><ul>
<li>H(key) = 3*KEY  mod  p<ul>
<li><strong>mod 实现逻辑上的循环</strong></li>
</ul>
</li>
<li>散列地址 —— 0 ~ m-1</li>
<li>函数能算出来的 —— 0 ~ p-1</li>
</ul>
<ul>
<li>对于冲突<ul>
<li>线性探测法  —— di</li>
<li>链地址法      —— 单链表</li>
</ul>
</li>
<li>求ASL<ul>
<li>先画这个</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>散列地址</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>比较次数</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>注意比较次数，<ul>
<li>一次性插入成功 —— 比较一次</li>
<li>和空位比较也算比较次数</li>
</ul>
</li>
<li>线性探测<ul>
<li>ASL_success  =  1/元素个数 * （ 总的比较次数累加_元素个数个 ）</li>
<li>ASL_loss         =  1/P * 总的比较次数累加_p个<ul>
<li>注意空的比较次数是1</li>
<li>不是空的需要比到空（空的也算一次）</li>
<li>注意不是 m个，是 p个（能用函数到达的）</li>
</ul>
</li>
</ul>
</li>
<li>链地址法<ul>
<li>ASL_s == Σ ( 单链表第K个 * K )    *    1 / 结点个<ul>
<li>不算结点表的空结点</li>
</ul>
</li>
<li>ASL_l  == Σ ( 第K个结点 * (K+1) )  *   1 / p<ul>
<li>到NULL比一次的时候，才知道是比较结束</li>
<li>结点表里的空结点算一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="排序方法-amp-排序结果"><a href="#排序方法-amp-排序结果" class="headerlink" title="排序方法 &amp; 排序结果"></a>排序方法 &amp; 排序结果</h3><h4 id="排序结果-到排序方法"><a href="#排序结果-到排序方法" class="headerlink" title="排序结果 到排序方法"></a>排序结果 到排序方法</h4><ul>
<li>有几个找到最终位置的？</li>
<li>冒泡？<ul>
<li>是否有交换</li>
<li>最后面是不是有序了</li>
</ul>
</li>
<li>选择？<ul>
<li>有序段 + 无序段</li>
<li>无序段 + 有序段</li>
<li>选中之后是<strong>交换</strong></li>
</ul>
</li>
<li>快速？<ul>
<li>pivot一趟定一个<ul>
<li>课本上是选择最左边的</li>
</ul>
</li>
<li>pivot 前小于pivot，后大于pivot</li>
<li>high、low两头跑，</li>
<li>先high，后low，</li>
<li>反常赋给没动的，</li>
<li>==找到pivot</li>
</ul>
</li>
</ul>
<h4 id="同一序列，不同方法"><a href="#同一序列，不同方法" class="headerlink" title="同一序列，不同方法"></a>同一序列，不同方法</h4><ul>
<li><p>直接插入排序</p>
<ul>
<li>最初定第一个是有序序列</li>
<li>然后，选无序序列的第一个插入<ul>
<li>从有序序列，<strong>后往前</strong>找</li>
</ul>
</li>
<li>第一趟之后，有序序列变 <strong>2 个</strong></li>
</ul>
</li>
<li><p>希尔排序</p>
<ul>
<li>定增量，</li>
<li>间隔为增量的小组，一共有增量个<ul>
<li>变小组间有序</li>
</ul>
</li>
<li>增量 == 1 —— 直接插入排序</li>
</ul>
</li>
<li><p>起泡排序</p>
<ul>
<li><strong>方向</strong><ul>
<li>从右往左，一趟定一个最值到最前面</li>
<li>从左网友，一趟定一个最值到最后面</li>
</ul>
</li>
<li>不断比较两个相邻的元素，调整两个元素的顺序</li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li>pivot选取<ul>
<li>一次定一个pivot</li>
</ul>
</li>
<li>low、high 两头走。<ul>
<li>相等时，是pivot的位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>直接选择</p>
<ul>
<li>遍历选取一个最值</li>
<li>和最前面的交换，形成有序序列</li>
</ul>
</li>
<li><p>归并排序</p>
<ul>
<li>默认2路归并<ul>
<li>每一次相邻的两个有序段（初始为1），归并成一个</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序</p>
<ul>
<li><p>默认从小到大排序 —— 最大堆/大根堆</p>
<ul>
<li><p>建立堆，（<strong>完全二叉树</strong>）调整（<strong>从最大的非叶子结点</strong>，编号–）</p>
</li>
<li><p>堆顶（<strong>根节点</strong>）取，和最后的结点（<strong>编号最大的叶子</strong>）<strong>交换</strong>，</p>
<p>   从上到下调整，得到<strong>第一趟排序的结果（调整堆完毕的）</strong>。</p>
<ul>
<li>有序的在最后面</li>
<li>调整是和孩子中  大的/小的  交换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="稳定性和性能"><a href="#稳定性和性能" class="headerlink" title="稳定性和性能"></a>稳定性和性能</h4><ul>
<li>堆排序<ul>
<li>没有额外空间 O(1)</li>
<li>不稳定</li>
<li></li>
</ul>
</li>
<li>快速排序<ul>
<li>使用递归工作栈(系统的)，O(log2(n))</li>
<li>不稳定</li>
<li>平均最快</li>
<li>最差 O(n^2)</li>
</ul>
</li>
<li>归并排序<ul>
<li>使用辅助数组 —— O(n)</li>
<li>稳定</li>
<li>O(n*log2(n))</li>
</ul>
</li>
</ul>
<p>![image-20200528211942961](C:\Users\gao xiwang\AppData\Roaming\Typora\typora-user-images\image-20200528211942961.png)</p>
<ul>
<li><p><strong>稳定的（常考）</strong> —— 归并、直接插入、冒泡</p>
</li>
<li><p>额外空间 —— 快速排序、归并排序</p>
</li>
<li><p>不变的O(n^2) —— 直接插入、冒泡、直接选择、</p>
</li>
<li><p>不变的O(n*log2(n)) —— 堆、归并</p>
</li>
<li><p>希尔排序 —— O(n^1.3)   (gap /= 2) —— 和gap有关</p>
</li>
<li><p>变化的</p>
<ul>
<li>快速排序 —— 平均O(n*log2(n))、最差 O(n^2)</li>
</ul>
</li>
<li><p>躺数和最初形态有关的</p>
<ul>
<li><strong>优化过的</strong>冒泡</li>
<li>快速排序</li>
</ul>
</li>
<li><p>基本有序的，对直接插入和希尔排序算法时间有帮助，<strong>趟数没帮助</strong></p>
</li>
<li><p><a href="https://www.cnblogs.com/Xieyang-blog/p/8340578.html" target="_blank" rel="noopener">https://www.cnblogs.com/Xieyang-blog/p/8340578.html</a></p>
<p>   ​      </p>
<pre><code>![img](https://uploadfiles.nowcoder.com/images/20190424/134156974_1556120409231_E69713B3B16599EC8758DB25FC06963D)

+ **无关**
+ 比较次数 —— 选择、基数
+ 移动次数 —— 归并、基数
+ 趟数        —— **除了** 冒泡(优化后)、快速
+ 算法复杂度 —— 选择、归并、堆、基数
+ **无关**</code></pre></li>
</ul>
<h3 id="二叉查找树-二叉排序树"><a href="#二叉查找树-二叉排序树" class="headerlink" title="二叉查找树/二叉排序树"></a>二叉查找树/二叉排序树</h3><ul>
<li>L&lt;N&lt;R —— 中序遍历得到有序序列从小到大</li>
<li><strong>从大到小？</strong><ul>
<li>RNL 顺序遍历得到</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>非空 <ul>
<li>in_Order( 左子树 )</li>
<li>访问root</li>
<li>in_Order( 右子树 ) </li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><ul>
<li>序列顺序输入<ul>
<li>二叉判定树，不是按照序列顺序，而是mid作root</li>
</ul>
</li>
<li>大了往右</li>
<li>小了往左</li>
</ul>
<h4 id="ASL-success"><a href="#ASL-success" class="headerlink" title="ASL_success"></a>ASL_success</h4><ul>
<li>== 1/元素个数  *  (层次 * 层次含有结点个数)</li>
</ul>
<h4 id="ASL-loss"><a href="#ASL-loss" class="headerlink" title="ASL_loss"></a>ASL_loss</h4><ul>
<li>先正则化</li>
<li>== 1/元素个数 * Σ( （层次-1） *  该层结点数目  )</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li>叶子</li>
<li>一个孩子</li>
<li>两个孩子<ul>
<li>左子树的最大值 —— 左子树最右边的叶子</li>
<li>右子树的最小值 —— 右子树最左边的叶子</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>折半查找判定树，ASL</li>
<li>散列表 + ASL</li>
<li>排序算法</li>
<li>二叉查找树</li>
</ul>
<h2 id="03-图"><a href="#03-图" class="headerlink" title="03 图"></a>03 图</h2><h3 id="DFS、BFS"><a href="#DFS、BFS" class="headerlink" title="DFS、BFS"></a>DFS、BFS</h3><ul>
<li><p>邻接表</p>
<ul>
<li>顶点表 —— 所有顶点  + 指向边表的指针</li>
<li>边表    ——  顶点的邻接点们，出边的指向 (出度) </li>
<li>DFS —— 顶点 – 边表中一个 – 顶点 – 边表中一个</li>
<li>BFS —— 顶点–遍历顶点的边表 – 遍历边表结点的边表</li>
</ul>
</li>
<li><p>邻接矩阵</p>
</li>
<li><p>BFS、DFS生成树</p>
</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li><p>找入度为0</p>
</li>
<li><p>访问完之后，删去结点和边</p>
</li>
<li><p>再找入度为0的</p>
</li>
<li><p>有环不能拓扑排序</p>
</li>
<li><p>有序的拓扑排序 —— 邻接矩阵是三角</p>
</li>
</ul>
<h3 id="Prim贪心算法"><a href="#Prim贪心算法" class="headerlink" title="Prim贪心算法"></a>Prim贪心算法</h3><ul>
<li>选点法，U 、V-U 、<ul>
<li>U初始是 一个点</li>
</ul>
</li>
<li>初始最小生成树邻近的最小权值<ul>
<li>不能有环</li>
</ul>
</li>
<li>直到 V == U</li>
<li>n-1 条边 —— n个结点</li>
</ul>
<h3 id="Kruskal-贪心算法"><a href="#Kruskal-贪心算法" class="headerlink" title="Kruskal 贪心算法"></a>Kruskal 贪心算法</h3><ul>
<li>选边法</li>
<li>初始点全在U里面</li>
<li>从小到大，选择权值小的<ul>
<li>不能有环</li>
</ul>
</li>
<li>n-1 条边 —— n个结点</li>
</ul>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>源点 到 其他所有点的最短路径。</p>
<ul>
<li><p>路径长度递增次序</p>
</li>
<li><p>手工模拟</p>
<table>
<thead>
<tr>
<th>源点 0</th>
<th>到1</th>
<th>到2</th>
<th>到3</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>距离distance</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>上一个点</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>distance 不断更新</p>
<ul>
<li>小于现在的才更新</li>
<li>同时更新上一个点</li>
</ul>
</li>
<li><p>每次选择distance最小的作 “起点” </p>
<ul>
<li>更新他的邻接点的distance</li>
</ul>
</li>
</ul>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><ul>
<li>关键路径 —— 最长的一条</li>
<li>&lt; i , j &gt;</li>
<li>Ve( j ) = Ve( i ) + 权值<ul>
<li>取大的</li>
<li>从前往后</li>
</ul>
</li>
<li>Vl( i ) = Vl( j ) - 权值<ul>
<li>取小的</li>
<li>从后往前</li>
</ul>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>DFS、BFS</li>
<li>拓扑</li>
<li>Prim</li>
<li>Kruskal</li>
<li>Dijkstra</li>
<li>关键路径</li>
</ul>
<h2 id="04-线性结构"><a href="#04-线性结构" class="headerlink" title="04 线性结构"></a>04 线性结构</h2><h3 id="栈、FILO"><a href="#栈、FILO" class="headerlink" title="栈、FILO"></a>栈、FILO</h3><h4 id="入栈顺序到出栈顺序"><a href="#入栈顺序到出栈顺序" class="headerlink" title="入栈顺序到出栈顺序"></a>入栈顺序到出栈顺序</h4><ul>
<li>暗含着可以边出边进</li>
<li><strong>卡特兰数</strong> —— 所有可能的合法的，数目</li>
<li><strong>以 X 开头的</strong></li>
<li><strong>如果编号大的先出来了 —— 其后的是逆序    !!!!</strong></li>
</ul>
<h4 id="符合某规则的出栈序列"><a href="#符合某规则的出栈序列" class="headerlink" title="符合某规则的出栈序列"></a>符合某规则的出栈序列</h4><ul>
<li>变量名：字母下划线开头<ul>
<li>数字不行</li>
</ul>
</li>
</ul>
<h3 id="队列假溢出"><a href="#队列假溢出" class="headerlink" title="队列假溢出"></a>队列假溢出</h3><ul>
<li><p>队头出，队尾进</p>
<ul>
<li>队尾元素指向元素</li>
<li>队头指向元素前空的</li>
</ul>
</li>
<li><p>拓展：双端队列</p>
</li>
<li><p>循环队列解决：%</p>
<ul>
<li>牺牲一个空间来区分队列 空 / 满<ul>
<li>标志位tag法（空/非空）、计数器</li>
</ul>
</li>
</ul>
</li>
<li><p>牺牲</p>
<ul>
<li>满 —— (rear +1) % max == front</li>
<li>空 —— rear == front</li>
</ul>
</li>
<li><p>标志位</p>
<ul>
<li>满 —— tag == 1 &amp;&amp; front == rear</li>
<li>空 —— tag == 0</li>
</ul>
</li>
</ul>
<h3 id="栈：中缀转后缀"><a href="#栈：中缀转后缀" class="headerlink" title="栈：中缀转后缀"></a>栈：中缀转后缀</h3><p>后缀表达式，无括号、不用考虑优先级别</p>
<ul>
<li>optr一个栈，存运算符<ul>
<li>栈外优先级高 —— 入栈</li>
<li>栈外有限级低 —— 出栈</li>
</ul>
</li>
<li>数字直接写入后缀表达式</li>
<li>最后把栈中的运算符弹出</li>
</ul>
<ul>
<li>技巧<ul>
<li>加括号 —— 移动运算符 —— 删除（）</li>
</ul>
</li>
</ul>
<h3 id="栈：求值后缀表达式"><a href="#栈：求值后缀表达式" class="headerlink" title="栈：求值后缀表达式"></a>栈：求值后缀表达式</h3><ul>
<li>扫描，不用考虑括号和运算符优先级别</li>
<li>数字，压栈</li>
<li>运算符，两个数字出栈运算得到结果，<ul>
<li>结果再入栈</li>
</ul>
</li>
</ul>
<h3 id="字符串-next、nextval"><a href="#字符串-next、nextval" class="headerlink" title="字符串 next、nextval"></a>字符串 next、nextval</h3><ul>
<li>next<ul>
<li>子串 —— 首、尾串<ul>
<li>首串尾串不能完全重叠</li>
</ul>
</li>
<li>1,2对应是 -1  和   0</li>
</ul>
</li>
<li><strong>nextval</strong> <ul>
<li><strong>第一个是 -1</strong></li>
<li><strong>和下标是next的字符比较</strong><ul>
<li><strong>相同 —— 继承  nextval</strong></li>
<li><strong>不同 —— 使用自己的next</strong></li>
</ul>
</li>
</ul>
</li>
<li>BF算法<ul>
<li>i  *  j 次匹配</li>
<li>i，j 都回溯</li>
</ul>
</li>
<li>KMP<ul>
<li>i  不回溯， 只有 j  回溯<ul>
<li>j  回溯到 <strong>nextval</strong> 下标位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>栈，进、出序列</li>
<li>队列判断 空满</li>
<li>栈： 后缀</li>
<li>next 和 nextval</li>
</ul>
<h2 id="05-概述"><a href="#05-概述" class="headerlink" title="05 概述"></a>05 概述</h2><h3 id="时间复杂度-——-频度"><a href="#时间复杂度-——-频度" class="headerlink" title="时间复杂度 —— 频度"></a>时间复杂度 —— 频度</h3><ul>
<li>*=2  ——  log2(N)  —— 步长</li>
<li>常量阶 —— O(1)</li>
</ul>
<h3 id="算法特性-⑤"><a href="#算法特性-⑤" class="headerlink" title="算法特性 ⑤"></a>算法特性 ⑤</h3><ol>
<li>有穷 —— 步骤和时间</li>
<li>确定 —— 无二义性</li>
<li>可行 —— 已经实现的基本操作实现</li>
<li>输入 —— 可以是 0 个</li>
<li>输出 —— 不可以是 0 个</li>
</ol>
<h3 id="算法评估"><a href="#算法评估" class="headerlink" title="算法评估"></a>算法评估</h3><ol>
<li>正确</li>
<li>易读/可读 —— 调试、修改、扩充</li>
<li>健壮</li>
<li>高效 —— 时间、空间</li>
</ol>
<h3 id="数据结构的——三要素"><a href="#数据结构的——三要素" class="headerlink" title="数据结构的——三要素"></a>数据结构的——<em>三要素</em></h3><ul>
<li>逻辑结构<ul>
<li>二类：线性、非线性<ul>
<li>线性表：数组、链表、栈、队列、字符串、广义表</li>
<li>非线性：树、图</li>
</ul>
</li>
<li>四类：线性表、集合、树、图</li>
</ul>
</li>
<li>存储结构<ul>
<li>顺序、链式、索引、散列</li>
</ul>
</li>
<li>运算 ： 查找、插入、删除、修改、排序</li>
</ul>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul>
<li>两类<ul>
<li>线性</li>
<li>非线性</li>
</ul>
</li>
<li>四类<ul>
<li>线性</li>
<li>集合</li>
<li>树</li>
<li>图</li>
</ul>
</li>
</ul>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul>
<li>顺序、链式、索引、散列</li>
</ul>
<h2 id="06-AVL平衡二叉树（最佳二叉排序树）"><a href="#06-AVL平衡二叉树（最佳二叉排序树）" class="headerlink" title="06 AVL平衡二叉树（最佳二叉排序树）"></a>06 AVL平衡二叉树（最佳二叉排序树）</h2><ul>
<li><p>树退化成单支树，优势不复存在</p>
</li>
<li><p>越矮越丰满查找效率越高</p>
</li>
<li><p>满/完全二叉树最好，但是难做 —— 转向AVL</p>
</li>
<li><p>AVL：所有结点，<strong>bf &lt;=1</strong></p>
<ul>
<li><p><strong>不一定是完全二叉树</strong></p>
</li>
<li><p>平衡因子 bf ：结点左右子树的高度差</p>
</li>
<li><p>最大高度证明是：</p>
</li>
<li><p>$$<br>   1.44*log(N+2)-1.328<br>   $$</p>
</li>
</ul>
</li>
</ul>
<h3 id="调整平衡"><a href="#调整平衡" class="headerlink" title="调整平衡"></a>调整平衡</h3><ul>
<li>由于会调整，导致插入的元素不一定作叶子</li>
</ul>
<h4 id="LL型调整"><a href="#LL型调整" class="headerlink" title="LL型调整"></a>LL型调整</h4><ul>
<li>找到<strong>值</strong>中间那个做根节点</li>
</ul>
<h4 id="RR型调整"><a href="#RR型调整" class="headerlink" title="RR型调整"></a>RR型调整</h4><ul>
<li>找到<strong>值</strong>中间那个作根节点</li>
</ul>
<h4 id="LR型调整"><a href="#LR型调整" class="headerlink" title="LR型调整"></a>LR型调整</h4><ul>
<li>找到<strong>值</strong>中间那个作根节点</li>
<li>最后要符合L&lt;N&lt;R</li>
</ul>
<h4 id="RL型调整"><a href="#RL型调整" class="headerlink" title="RL型调整"></a>RL型调整</h4><ul>
<li>同LR</li>
</ul>
<h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><ul>
<li>构造排序二叉树那一套</li>
<li>随时注意不平衡<ul>
<li>调整 —— 四个类型</li>
<li>找bf &gt;1 的结点（最矮的失衡结点开始）</li>
</ul>
</li>
</ul>
<h3 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h3><ul>
<li>所有结点 bf &lt; = 1</li>
</ul>
<h3 id="根节点失衡"><a href="#根节点失衡" class="headerlink" title="根节点失衡"></a>根节点失衡</h3><ul>
<li>沿着最长的分支找3个结点</li>
<li>值处于中间的 —— 作根</li>
<li>L&lt;N&lt;R</li>
</ul>
<h3 id="AVL树是一棵排序树"><a href="#AVL树是一棵排序树" class="headerlink" title="AVL树是一棵排序树"></a>AVL树是一棵排序树</h3><ul>
<li><p>中序遍历 </p>
<ul>
<li>L&lt;N&lt;R —— 升序</li>
<li>L&gt;N&gt;R —— 降序</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>应用题考点</tag>
      </tags>
  </entry>
  <entry>
    <title>循环链表 + 双链表</title>
    <url>/2020/07/25/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8+%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00考点"><a href="#00考点" class="headerlink" title="00考点"></a>00考点</h3><p>选择、填空、判断</p>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>循环——每一个结点触发都能找到任意一个结点</p>
</li>
<li><p>双链表 (data | next | prior) </p>
<ul>
<li><p>前驱 + 后继 </p>
</li>
<li><p>空间换时间</p>
</li>
<li><p>p的前驱的后继 == p的后继的前驱 = p</p>
</li>
<li><p>双链表的插入</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先链接前驱，后链接后继</span></span><br><span class="line">s-prior = p -&gt;prior;</span><br><span class="line">p-&gt;prior-&gt;next = s; <span class="comment">// —— 先</span></span><br><span class="line"></span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p-&gt;prior = s;	<span class="comment">// —— 后</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除头结点：</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node *p；p = head；head = head-&gt;next；<span class="built_in">free</span>（p）；			<span class="comment">// 没有表头节点 	</span></span><br><span class="line">Node *p；p = head-&gt;next；head-&gt;next = p-&gt;next; <span class="built_in">free</span>(p); <span class="comment">// 有表头节点</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>单循环链表</p>
<ul>
<li>存在一个环，尾结点指向头结点<ul>
<li><strong>空？</strong>—— <code>head-&gt;next = head;</code></li>
</ul>
</li>
<li>常常没有头指针，只有尾指针<ul>
<li>表尾 + 表头都容易找到</li>
</ul>
</li>
</ul>
</li>
<li><p>双循环链表</p>
<ul>
<li>两个环。前驱 + 后继</li>
<li>循环表的空？ —— <code>head == head-&gt;next == head-&gt;prior</code></li>
<li>双链表的空？ —— <code>head-&gt;next==NULL;head-&gt;prior==NULL</code></li>
</ul>
</li>
</ul>
<h3 id="03-习题"><a href="#03-习题" class="headerlink" title="03 习题"></a>03 习题</h3><ul>
<li><p>删除双向循环链表</p>
<ul>
<li>p的前驱的后继到p的后继。p的后继的前驱到p的前驱。</li>
</ul>
</li>
<li><p>链表的插入/删除需要找到前驱。</p>
</li>
<li><p>两个带尾指针的单循环链表AB，连接成一个单循环链表</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A尾指向B头 // B尾指向A头</span></span><br><span class="line">p = A-&gt;next;<span class="comment">//A头结点</span></span><br><span class="line">A-&gt;next = B-&gt;next-&gt;next;<span class="comment">//A指向B的首元结点</span></span><br><span class="line"><span class="keyword">delete</span> B-&gt;next;	<span class="comment">// 释放头结点</span></span><br><span class="line">B-&gt;next = p;</span><br></pre></td></tr></table></figure>

<ul>
<li>B头指针。B-&gt;next 头结点。</li>
</ul>
</li>
<li><p>链表A，有data、next、prior。next形成单链循环表。prior指针域为NULL。怎么改成双向循环链表</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p的后继结点的前驱，指向p</span></span><br><span class="line"><span class="keyword">while</span>(A-&gt;next-&gt;pre == <span class="literal">NULL</span>)&#123;</span><br><span class="line">	A-&gt;next-pre = A;</span><br><span class="line">    A = A-&gt;next;</span><br><span class="line">&#125;<span class="comment">// 循环链表可以动头指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线性表实现方法的比较。</p>
<ul>
<li>顺序表<ul>
<li>插入、删除 O(n)。查找O(1)，求表长O(1)</li>
<li>存储密度大，无结构性开销</li>
<li>需要预先确定大小</li>
</ul>
</li>
<li>链表<ul>
<li>查找 O(n）。插入删除O(1)。找到第i个元素O(n)。求表长O(n)</li>
<li>存储利用ptr，动态地为新的元素在堆区分配空间</li>
<li>每个元素都有结构性开销</li>
</ul>
</li>
</ul>
</li>
<li><p>循环单链表，</p>
<ul>
<li>h为头指针。p指向链尾的条件是 —— <code>p-&gt;next == h</code></li>
<li>最大优点 —— 任意位置出发都能找到要找的元素</li>
</ul>
</li>
<li><p>双链表最大优点 —— 便于找到前驱和后继</p>
</li>
<li><p>循环链表也是线性表</p>
</li>
<li><p>链表 —— 插入删除数据方便</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>树和森林</title>
    <url>/2020/07/25/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>树的存储结构，树、森林和二叉树的相互转换、树和森林的遍历运算和基本运算</li>
<li>高频：树、森林、二叉树的相互转换</li>
<li>主要客观题，算法少</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>了解，双亲表示法：两个域的数组，data、parent。</p>
<ul>
<li>方便找结点双亲、查找孩子难、顺序存储结构</li>
</ul>
</li>
<li><p>了解，孩子表示法</p>
<ul>
<li>结点的度，设置结点的指针个数</li>
<li>data、child1、child2、child3、child4</li>
<li>节省存储。<strong>不同的数据元素节点构造不一样</strong>。操作不便</li>
</ul>
</li>
<li><p>了解，孩子表示法</p>
<ul>
<li>按照树的度进行设置指针个数</li>
</ul>
</li>
<li><p>了解，孩子链表法</p>
<ul>
<li>顺序（结点） + 链表（孩子）</li>
<li>找孩子容易，找双亲难</li>
</ul>
</li>
<li><p>了解，双亲孩子链表法</p>
<ul>
<li>顺序（结点+parent）+链表（孩子）</li>
</ul>
</li>
<li><p><strong>重点</strong>，左孩子右兄弟表示法 / 二叉树表示法</p>
<ul>
<li>firstchild、data、nextSibiling(下一个兄弟)</li>
<li>树转二叉树</li>
</ul>
</li>
<li><p>树定义</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">childSibilingTree</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>: </span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">                elemType data;</span><br><span class="line">                Node* firstChild, *nextSibiling;</span><br><span class="line">                Node():firstChild(<span class="literal">NULL</span>),nextSibiling(<span class="literal">NULL</span>)&#123; &#125;</span><br><span class="line">                Node(elemType val, Node*l = <span class="literal">NULL</span>, Node*r = <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    data = val; firstChild = l; nextSibiling = r;</span><br><span class="line">                &#125;<span class="comment">//</span></span><br><span class="line">                ~Node();</span><br><span class="line">            &#125;<span class="comment">//struct</span></span><br><span class="line">        	Node* root;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树到二叉树转换</p>
<ul>
<li>（手工模拟）<ul>
<li>连线，在兄弟结点之间连线，</li>
<li>删线，每个结点除了保留与其最左孩子的连线外，删去与其他孩子之间的连线</li>
<li>旋转，顺时针旋转 45°</li>
</ul>
</li>
<li>根节点右子树一定为空，根节点没有右兄弟</li>
</ul>
</li>
<li><p>森林到二叉树转换</p>
<ul>
<li>（手工模拟）<ul>
<li>连线，在兄弟结点之间连线。包括森林中所有树的根节点。</li>
<li>删线，每个结点除了保留与其最左孩子的连线外，删去与其他孩子之间的连线</li>
<li>旋转，顺时针旋转 45°</li>
</ul>
</li>
<li>所有子树的根节点都是兄弟</li>
<li>根节点的右子树上有多少右子树根节点，森林就有多少子树。</li>
</ul>
</li>
<li><p>二叉树到森林</p>
<ul>
<li>连线，双亲–孩子，先连成虚线</li>
<li>删线，删除兄弟之间的连线<ul>
<li>（节点的右指针指向孩子），删除的是根节点–右指针</li>
</ul>
</li>
<li>逆时针旋转45°，虚线转实线</li>
</ul>
</li>
<li><p><strong>重点：</strong>树和森林的遍历</p>
<ul>
<li>DFS：前序、后序</li>
<li>BFS：层次遍历</li>
</ul>
</li>
<li><p>前序</p>
<blockquote>
<ul>
<li>非空<ul>
<li>访问根节点</li>
<li>依次前序遍历树的第 i 棵子树</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>树的前序 == 二叉树的前序</p>
</li>
<li><p>树的后序 == 二叉树的中序 </p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历树（森林）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:preOrder_1(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            preOrder_1(t-&gt;firstChild);</span><br><span class="line">            t = t-&gt;nextSibiling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 前序遍历二叉树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:preOrder_2(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            preOrder_2(t-&gt;firstChild);</span><br><span class="line">            preOrder_2(t-&gt;nextSibiling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>后序</p>
<blockquote>
<ul>
<li>非空<ul>
<li>依次后序遍历树的第 i 棵子树</li>
<li>访问树的根节点</li>
</ul>
</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历树（森林）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:postOrder_1(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span> != t)&#123;</span><br><span class="line">            postOrder_1(t-&gt;firstChild);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            t = t-&gt;nextSibiling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 后序遍历二叉树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:postOrder_2(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            postOrder_2(t-&gt;firstChild);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			postOrder_2(t-&gt;nextSibiling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层序遍历</p>
<ul>
<li><p>树 —— 编号</p>
</li>
<li><p>森林 —— 子树的根在同一层</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借助队列,树和森林</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">childSibiling</span>&lt;emelmType&gt;:</span>:levelOrderTraverse()consrt&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; Q;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="comment">// 森林的所有根节点入队</span></span><br><span class="line">            Q.push(p);</span><br><span class="line">            p = p-&gt;nextSibiling;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            p = Q.front(); 	<span class="comment">//取栈中的根节点</span></span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            p = p-&gt;firstChild;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                <span class="comment">// 当前节点的所有孩子入队</span></span><br><span class="line">                Q.push(p);</span><br><span class="line">                p = p-&gt;nextSibiling;</span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;<span class="comment">// func</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>求树的高度</p>
<blockquote>
<ul>
<li>空子树 —— 0</li>
<li>非空     —— 森林的高度为 <strong>max{子树孙林的高度+1，兄弟森林的高度}</strong></li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:height(Node *t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> lh = height(t-&gt;firstChild), rh = height(t-&gt;nextSibiling);</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>+lh)&gt;rh?lh+<span class="number">1</span>:rh;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求节点总数</p>
<ul>
<li><p>递归前序遍历树</p>
<blockquote>
<ul>
<li>空子树 —— 0</li>
<li>非空     ——  == 1 + 左子树森林的结点数 + 右子树森林的结点数</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:size(Node* t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(t-&gt;firstChild) + size(t-&gt;nextSibiling);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>求叶子结点</p>
<ul>
<li><p>递归前序遍历树</p>
<blockquote>
<ul>
<li>空子树  ——  子树节点数为0</li>
<li>当前节点无firstChild ，那么也不会有 其他孩子—— ==1 + 兄弟森林中的叶子结点</li>
<li>当前节点有fiestChild —— == 子树森林的叶子结点数 + 兄弟森林的叶子结点</li>
</ul>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">childSibilingTree</span>&lt;elemType&gt;:</span>:leafNum(Node* t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == t)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;firstChild == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + leafNum(t-&gt;nextSibiling);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> leafNum(t-&gt;nextChild) + leafNum(t-&gt;nextSibiling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02   习题"></a>02   习题</h3><ul>
<li>树转换成二叉树，结点 u 是结点 v 的父节点的父节点<ul>
<li>可能有四种 —— LL、LR、RL、RR —— 父子或者兄弟</li>
</ul>
</li>
<li>叶子结点数目<ul>
<li>n0  ==  （k-1)*nk  + 1</li>
</ul>
</li>
<li>扫把形的树 —— 非叶子结点，一个一层。<ul>
<li>转二叉树 —— 一直只有 firstchild指针非空，到一直只有nextSibiling指针非空</li>
</ul>
</li>
<li>树转二叉树，叶子结点 —— firstchild指针NULL的</li>
<li>知道森林的边和结点数 —— 子树数目<ul>
<li>一棵树把所有边都用了，其余的都是只有root结点的树</li>
<li>n个结点 —— n-1 条边</li>
</ul>
</li>
<li>二叉树中的右孩子，在树中其实是兄弟关系</li>
<li>二叉树的根节点的右子树，全是森林的树（除了第一棵）<ul>
<li>左子树 —— n1 <strong>- 1</strong></li>
<li>右子树 —— n2 + n3 + n4</li>
</ul>
</li>
<li>F是个森林，B是有F变换的得到的二叉树。若F中有n个非叶子结点<ul>
<li>B中右指针非空的有多少个</li>
<li><strong>特殊情况推导</strong><ul>
<li>森林只有两棵只有<strong>根节点的树</strong>，转成二叉树 —— 后验证</li>
</ul>
</li>
</ul>
</li>
<li>已知先序和后序，构造<strong>森林</strong><ul>
<li>二叉树的先序和中序  ——  二叉树<ul>
<li>先序——根</li>
<li>中序 + 根 —— 子树</li>
<li>子树 + 先序 —— 根 ——循环</li>
</ul>
</li>
<li>二叉树转森林<ul>
<li><strong>加线 —— 根节点 和 除了firstchild 之外的孩子加虚线</strong></li>
<li><strong>删线 —— 所有NR线（实线）删去。</strong></li>
<li><strong>旋转 —— 逆时针旋转 45°</strong></li>
<li>根节点 + 左子树 —— 第一棵树</li>
<li>右子树，每一个RR都是一个根节点</li>
</ul>
</li>
</ul>
</li>
<li>树的后根次序 + 结点的度 ，求树<ul>
<li>叶子结点， n0 ， 度数是0</li>
<li>B、D、E、F、C、G、J、K、I、L、H、A、</li>
<li>0、0、0、0、3、0、0、0、2、0、2、4<ul>
<li>DEF—— C（前面度数个结点）</li>
<li>JK   ——  I  </li>
<li>IL    —— H</li>
<li>BCGH  —— A  ( 前面没出现过的 )</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>树和森林</tag>
      </tags>
  </entry>
  <entry>
    <title>算法相关术语</title>
    <url>/2020/07/25/%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="算法相关概念和术语"><a href="#算法相关概念和术语" class="headerlink" title="算法相关概念和术语"></a>算法相关概念和术语</h1><h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><h4 id="算法和程序"><a href="#算法和程序" class="headerlink" title="算法和程序"></a>算法和程序</h4><ul>
<li>算法 —— 指令的优先序列，求解特定问题的步骤的描述</li>
<li>五个特性<ul>
<li>有穷性 —— 步骤、执行时间 有限</li>
<li>确定性 —— 无二义性、唯一的执行路径（同输入、同输出）</li>
<li>可行性 —— 可通过已经实现的基本运算执行有限次实现</li>
<li>输入 —— 零个或多个 —— 可以没有</li>
<li>输出 —— 一个或多个 —— 不能没有</li>
</ul>
</li>
<li>算法 ！= 程序<ul>
<li>算法有限、程序可以无限 （例如 OS 程序）</li>
<li>程序必须具体语言，算法不用</li>
</ul>
</li>
<li>评估算法<ul>
<li>正确 —— 实现预定功能</li>
<li>易读 —— 便于调试、修改、阔成</li>
<li>健壮 —— 例如三角形三条边的合法性</li>
<li>高效率 —— 时间、空间性能</li>
</ul>
</li>
<li>方法<ul>
<li>事前 —— 未 code</li>
<li>事后 —— code 运行</li>
</ul>
</li>
</ul>
<h4 id="时间复杂度-——-计算量的大小"><a href="#时间复杂度-——-计算量的大小" class="headerlink" title="时间复杂度 —— 计算量的大小"></a>时间复杂度 —— 计算量的大小</h4><ul>
<li><p>时间复杂度 T(N) = O( f(N) ) —— time complexity</p>
<ul>
<li>N —— 算法规模 —— 趋于无穷大<ul>
<li>不考虑具体时间，</li>
<li>只考虑运行时间函数的<strong>数量级</strong><ul>
<li><strong>忽律低阶项，忽律高阶系数 O(f(N))。</strong></li>
<li>如果存在 c &gt; 0 和正整数 N_0 &gt;= 1，当 N&gt;N_0 时，有 T(N)&lt;c*f(N)。给出时间复杂度的上界</li>
</ul>
</li>
</ul>
</li>
<li><strong>规范答题分析过程</strong>：<ul>
<li>如果存在 c &gt; 0 和正整数 N_0 &gt;= 1，当 N&gt;N_0 时，有 T(N)&lt;c*f(N)。给出时间复杂度的上界</li>
<li>给出 c，N_0。T(N)&lt;=c*某成立 —— T(N) = O(某)。</li>
<li>忽律低次项和高次项系数</li>
</ul>
</li>
<li>T(N) = O(f(N)) ，只是说明在 N 趋于无限的时候，的时间复杂度大小<ul>
<li>规模不是很大的时候，有可能出现翻转</li>
</ul>
</li>
</ul>
</li>
<li><p>语句的频度 frequency count</p>
<ul>
<li>语句执行次数</li>
<li>借此分析 T(N)</li>
</ul>
</li>
<li><p>执行一万次 —— O(1) —— 常量</p>
<ul>
<li>我们认为一万是系数，要忽略掉<strong>确切</strong>的数字</li>
</ul>
</li>
<li><p><code>for(int i = 0;i&lt;n;i*=2)</code> —— log(N) —— 底数可以转化成系数</p>
</li>
<li><p>平方阶</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;n;j++) <span class="comment">// n</span></span><br><span class="line">        ++x;</span><br><span class="line">&#125;<span class="comment">// n**2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;i;j++) <span class="comment">// i</span></span><br><span class="line">        ++x;</span><br><span class="line">&#125; <span class="comment">// 1,2,3,4,5,6....  —— n*(n+1) / 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线性对数阶 —— O( n*log(n) )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i *= <span class="number">2</span>)&#123;  &#125; <span class="comment">//log(n+1)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i *= <span class="number">2</span>)&#123;  &#125; <span class="comment">// n+1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i *= <span class="number">2</span>)&#123;  &#125; <span class="comment">// n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i *= <span class="number">2</span>)&#123;  &#125; <span class="comment">// n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵相乘</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j &lt;= n ;++j )&#123;</span><br><span class="line">		c_mat[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">1</span> ;k&lt;n;++k)&#123;</span><br><span class="line">			c_mat[i][j] += a_mat[i][k] * b_mat[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>冒泡排序</p>
<ul>
<li>最好情况 —— 1 趟 ；size-1 次 比较 ； 0 次交换</li>
<li>最差情况 —— n-1 趟 ；1-(n-1) —— n<em>(n-1)/2 次 比较 ； n</em>(n-1)/2 次交换</li>
<li>最好 —— N ；<strong>最坏 —— N^2 ；平均 —— N^2</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(RecType a[],<span class="keyword">int</span> size)</span></span>&#123; <span class="comment">// RecType 记录的类型</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size<span class="number">-1</span> ;++i)&#123;		<span class="comment">// 趟数 —— size-1</span></span><br><span class="line">        flag = <span class="number">0</span>；<span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;size-j<span class="number">-1</span>;j *= <span class="number">2</span>)&#123;	<span class="comment">//  比较的元素的个数 —— size - i - 1</span></span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap();</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="空间复杂度-——-辅助存储量"><a href="#空间复杂度-——-辅助存储量" class="headerlink" title="空间复杂度 —— 辅助存储量"></a>空间复杂度 —— 辅助存储量</h4><ul>
<li>规模 —— N<ul>
<li>大小为 n 的辅助一维数组 —— O(N)</li>
<li>大小为 n^2 的辅助二维数组 —— O(N^2)</li>
<li>大小为 确切数字 的辅助数组一维数组 —— O(1) ）</li>
</ul>
</li>
<li>原地工作<ul>
<li>O(1)</li>
<li>需要的<strong>额外空间</strong>相对于输入数据量，只是一个常数 —— O(1)</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>递归求阶乘</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n*fact(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>共调用 n-1 次，或者说栈的深度是 n-1</p>
<ul>
<li>O(n-1) —— O(n)</li>
</ul>
</li>
<li><p><strong>假设法 —— 调用 k 次,而后结合终止条件，判断 k = 什么 n</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &lt; n)		sum += ++i;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设调用 k 次 <code>sum +=i；</code></p>
<p>​ 那么终止条件 —— sum = 1+2+3+…+k = k*(k+1)/2 &lt; n</p>
<p>​ —— k = n^(1/2)</p>
</li>
<li><p>算法的五个特性 —— 有穷、确定、可行、输入、输出</p>
</li>
<li><p>评估算法的指标 —— T(N) &amp; O(N)</p>
</li>
</ul>
<p>#</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>定义</tag>
      </tags>
  </entry>
  <entry>
    <title>静态查找表</title>
    <url>/2020/07/25/%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-考点"><a href="#00-考点" class="headerlink" title="00 考点"></a>00 考点</h3><ul>
<li>顺序、折半、分块查找</li>
<li>高频：折半查找&amp;判定树 </li>
<li>5~10%</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>集合中数据元素没有逻辑关系</p>
</li>
<li><p>关键字 ： 一个数据元素区别于其他的唯一标识 （键值、关键字值）</p>
</li>
<li><p>集合的运算</p>
<ul>
<li>查找（内部、外部）</li>
<li>按关键字排序</li>
</ul>
</li>
<li><p>集合的存储</p>
<ul>
<li>任何容器都可</li>
<li>常用，线性表（折半）和树（二叉查找，AVL）</li>
<li>唯一一个适合和处理集合 —— HASH（散列表，存储 + 查找）</li>
</ul>
</li>
<li><p>查找表</p>
<ul>
<li>静态</li>
<li>动态</li>
</ul>
</li>
<li><p>ASL 平均查找长度 Average Search Length —— 必须会算</p>
<ul>
<li><p>对key的平均比较次数</p>
</li>
<li><p>$$<br>   ASL = Σ ( P_i*C_i)<br>   $$</p>
</li>
<li><p>pi —— 查找第 i 个元素的概率</p>
</li>
<li><p>Ci —— 查找第 i 个元素需要经过的比较次数</p>
</li>
</ul>
</li>
<li><p>无序表只能顺序查找</p>
<ul>
<li><p>引入，监视哨兵，检索失败返回 0 </p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RecType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">seqSearch</span>(<span class="title">vector</span>&lt;RecType&gt; &amp;<span class="title">data</span>, <span class="title">const</span> <span class="title">RecType</span> &amp;<span class="title">k</span>)&#123;</span></span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    	data[<span class="number">0</span>] = k;<span class="comment">//哨兵</span></span><br><span class="line">    	<span class="keyword">for</span>(i=data.size()<span class="number">-1</span>; k!=data[i]; --i);<span class="comment">//从后向前查找，只找位置</span></span><br><span class="line">    	<span class="comment">//体会哨兵的作用</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>顺序表（被查找的元素不存在时，不需要查到表位）</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RecType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">SortedSeqSearch</span>(<span class="title">vector</span>&lt;RecType&gt; &amp;<span class="title">data</span>, <span class="title">const</span> <span class="title">RecType</span> &amp;<span class="title">k</span>)&#123;</span></span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    	data[<span class="number">0</span>] = k;</span><br><span class="line">    	<span class="keyword">for</span>(i=data.size()<span class="number">-1</span>; k&lt;data[i];--i);	<span class="comment">// &gt;= data[i]就会退出</span></span><br><span class="line">    	<span class="keyword">if</span>(k == data[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查找成功<ul>
<li>ASL = 1/n * Σ(n -i -1) = 1/n * (1 + 2 +…+n) == (n+1)/2</li>
</ul>
</li>
<li>失败<ul>
<li>n+1 （监视哨兵）</li>
</ul>
</li>
</ul>
</li>
<li><p>折半查找（half-interval Search）</p>
<ul>
<li><p>要求<strong>有序</strong>，且必须顺序存储，链表不行。</p>
<blockquote>
<ul>
<li>data[mid] == k —— 成功</li>
<li>data[mid]  &gt;  k —— 在前半段</li>
<li>data[mid]  &lt;  k —— 在后半段</li>
</ul>
</blockquote>
</li>
<li><p>mid = (low+high) / 2</p>
</li>
<li><p>low &gt; high  —— 退出</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RecType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">BinarySearch</span>(<span class="title">const</span> <span class="title">vector</span>&lt;RecType&gt; &amp;<span class="title">data</span>, <span class="title">const</span> <span class="title">RecType</span> &amp;<span class="title">k</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = data.size()<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        mid = (high + low ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k==data[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; data[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RecType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">BinarySearch_2</span>(<span class="title">const</span> <span class="title">vector</span>&lt;RecType&gt; &amp;<span class="title">data</span>, <span class="title">const</span> <span class="title">RecType</span> &amp;<span class="title">k</span>，<span class="title">int</span> <span class="title">low</span>， <span class="title">int</span> <span class="title">high</span>&#123;</span></span><br><span class="line">        <span class="comment">// 递归常常通过参数的变化，来向下一层传递信息</span></span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">// 出口1</span></span><br><span class="line">        <span class="keyword">int</span> mid = (high + low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == data[mid])		<span class="comment">// 出口2</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; data[mid])</span><br><span class="line">            <span class="keyword">return</span> BinarySearch_2(data, k, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BinarySearch_2(data, k, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>折半查找的判定树</p>
<ul>
<li><p>结点 —— 元素在顺序存储中的位置</p>
<blockquote>
<ul>
<li>根节点 —— mid</li>
<li>左侧 —— 左子树</li>
<li>右侧 —— 右子树</li>
</ul>
</blockquote>
</li>
<li><p>查找</p>
<blockquote>
<ul>
<li>大于结点向右走</li>
<li>小于结点向左走</li>
</ul>
</blockquote>
</li>
<li><p>查找成功</p>
<ul>
<li>AVL = 1/元素个数 * （ 层数 * 该层的结点 ）</li>
</ul>
</li>
<li><p>查找失败</p>
<ul>
<li>正则化（添加查找失败的结点）</li>
<li>AVL = 1/外部结点个数   *   （（层数-1）  *   该层的个数 ）</li>
</ul>
</li>
<li><p>最大的成功检索长度 == 最大的失败检索 == 高度</p>
</li>
<li><p>查找成功的平均查找长度</p>
<ul>
<li>ASL  ==  log2( n + 1)  -   1</li>
</ul>
</li>
<li><p>O( log2(N) )</p>
</li>
</ul>
</li>
<li><p>分块查找 / 索引顺序块的查找：索引表 + 查找块</p>
<ul>
<li><p>处理大量数据，分成若干块</p>
<blockquote>
<ul>
<li>块内的元素可以有序，也可以无序</li>
<li>块之间必须是有序的</li>
<li>每块不需要均匀</li>
</ul>
</blockquote>
</li>
<li><p><strong>索引表</strong> —— 块内最大的关键字、块内的起始地址</p>
<ul>
<li>递增有序，存储<ul>
<li>各块中最大的关键字</li>
<li>各块起始地址</li>
<li>可能还需要块内存了多少个元素</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>索引表上的查找</p>
<ul>
<li><p>某个key</p>
<blockquote>
<ul>
<li>大于某个块的最大值，不在此块内<ul>
<li>一直找到小于某块的最大值，在这个块里</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>折半查找 —— 每次往一个方向缩短查找范围<ul>
<li>找一个不存在的元素。最多比较 log2(n+1) “↑” —— 二叉树的高度</li>
<li>不能构成折半查找关键字序列的  —— 构不成单支的树</li>
<li>改进 —— 跳跃查找，</li>
</ul>
</li>
<li>折半查找二叉树<ul>
<li>向下取整 —— 右分支可能略长</li>
<li>向上取整 —— 左分支可能长</li>
<li>但是，总的不可能，有往右拐的，也有往左拐的</li>
<li>找个 1~10 ，带入一下</li>
</ul>
</li>
<li>怎么构造折半查找的二叉判定树<ul>
<li>不是根据排好序的序列去形成</li>
<li><strong>注意 —— 是靠选取mid，分割子序列，再找mid分割子序列</strong></li>
<li><strong>重点是序列的mid</strong></li>
</ul>
</li>
<li>折半查找的平均查找长度<ul>
<li>画查找树—— 查找树是一棵完全二叉树，并且右分支长</li>
<li>1/元素个数 * Σ( 层数*该层结点数 )</li>
</ul>
</li>
<li>对于有序表和无序表<ul>
<li>顺序和遍历查找 —— 成功ASL相同、失败ASL不同</li>
</ul>
</li>
<li>关于折半查找 —— 首先画出判定树</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/07/25/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00考点"><a href="#00考点" class="headerlink" title="00考点"></a>00考点</h3><ul>
<li>概念、特点FIFO。循环队列、基本算法(出入、取队首、求长度)</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p><strong>表头front出队，表尾rear入队</strong>。两头开管道式。</p>
</li>
<li><p>顺序队列</p>
<ul>
<li><p>front指向队头元素的前一个位置，rear指向队尾指针 </p>
</li>
<li><p>空 —— front== rear == -1 </p>
</li>
<li><p>假溢出（*<em>假上溢 *</em>）—— 循环队列</p>
<ul>
<li><p>空满难辨</p>
<ul>
<li><strong>牺牲一个存储空间</strong>。</li>
<li>引入一个标识变量，表示空/满</li>
<li>引入计数器</li>
</ul>
</li>
<li><p><strong>满 ： (front +1) mod maxSize == front</strong></p>
</li>
<li><p><strong>空 ： front == rear</strong></p>
</li>
<li><p><strong>队列元素个数 ：(rear-front+maxSize) mod maxSize</strong></p>
</li>
<li><p><strong>入队 ： rear = (rear + 1)mod maxSize</strong></p>
</li>
<li><p><strong>出队 ：front = (front+1) mod maxSize</strong></p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">seqQueue</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">        	T *data;</span><br><span class="line">        	<span class="keyword">int</span> maxSize;</span><br><span class="line">        	<span class="keyword">int</span> front,rear;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        	seqQueue(<span class="keyword">int</span> initsize = <span class="number">100</span>);</span><br><span class="line">        	~seqQueue()&#123; <span class="keyword">delete</span> []data &#125;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="keyword">const</span></span>&#123; <span class="keyword">return</span> front==rear; &#125;;</span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">()</span><span class="keyword">const</span></span>&#123; <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize == front; &#125;</span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> (rear - front + maxSize)%manxSize;&#125;</span><br><span class="line">        	</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span></span>&#123;</span><br><span class="line">				</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="function">T <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">        	<span class="function">T <span class="title">getFront</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	seqQueue&lt;T&gt;::seqQueue(<span class="keyword">int</span> initsize)&#123;</span><br><span class="line">        <span class="comment">// 合法</span></span><br><span class="line">        <span class="keyword">if</span>(initszie &lt;= <span class="number">0</span>)	<span class="keyword">throw</span> badSzie();</span><br><span class="line">        data = <span class="keyword">new</span> T[initsize];	<span class="comment">//new</span></span><br><span class="line">        <span class="comment">// 更新信息</span></span><br><span class="line">        maxSize = initsize;	</span><br><span class="line">        front = rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">void</span> seqQueue&lt;T&gt;::enQueue(<span class="keyword">const</span> T &amp;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>((rear+<span class="number">1</span>)%maxSize == front)	resize();</span><br><span class="line">        <span class="comment">// front &amp; rear的移动不是单纯的 ++</span></span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">        data[rear] = val;</span><br><span class="line">    &#125;</span><br><span class="line">	T seqQueue&lt;T&gt;::DeQueue()&#123;</span><br><span class="line">        <span class="keyword">if</span>(Empty())	<span class="keyword">throw</span> outofRange();</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;<span class="comment">// +</span></span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line">	T seqQueue&lt;T&gt;::getFront()&#123;</span><br><span class="line">        <span class="keyword">if</span>(Empty())	<span class="keyword">throw</span> outofRange();</span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>链队列</p>
<ul>
<li><p>空间换时间 —— 两个指针</p>
</li>
<li><p>空 —— 两个NULL</p>
</li>
<li><p><strong>原空</strong>，第一个进队 —— 修改两个</p>
</li>
<li><p>之后进队修改队尾，出队修改队首</p>
</li>
<li><p>只一个时出队，<strong>变空</strong> —— 修改两个</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">linkList</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">                T data;		Node *next;</span><br><span class="line">                Node(<span class="keyword">const</span> T &amp;x, node *N = <span class="literal">NULL</span>)&#123; data=x;next=N &#125;;<span class="comment">//</span></span><br><span class="line">                Node::Next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">                ~node()&#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        	Node *front,*rear;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        	linkQueue()&#123;front = rear = <span class="literal">NULL</span>&#125;</span><br><span class="line">        	~linkQueue()&#123;claer();&#125;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> front==<span class="literal">NULL</span>;&#125;</span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">        	<span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rear == <span class="literal">NULL</span>)</span><br><span class="line">                    front = rear = <span class="keyword">new</span> Node(x);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rear-&gt;next = <span class="keyword">new</span> node(x);</span><br><span class="line">                    rear = rear-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="function">T <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Empty())	<span class="keyword">throw</span> outofRange();</span><br><span class="line">                Node *p = front;</span><br><span class="line">                T val = front-&gt;data;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                <span class="keyword">if</span>(front == <span class="literal">NULL</span>)	rear = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>	val;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="function">T <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Empty())	<span class="keyword">throw</span> outofRange();</span><br><span class="line">                <span class="keyword">return</span>	front-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Node *p = front;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;<span class="comment">//while</span></span><br><span class="line">            &#125;<span class="comment">//size()</span></span><br><span class="line">    &#125;;<span class="comment">//class</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li>顺序队列采用循环，公式麻烦</li>
<li>链式队列，存储密度小，结构性开销大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="03-习题"><a href="#03-习题" class="headerlink" title="03 习题"></a>03 习题</h3><ul>
<li><p>打印机和主机之间的缓冲 —— 队列</p>
</li>
<li><p>火车轨道问题</p>
<ul>
<li>队列的出队顺序，符合入队顺序。</li>
</ul>
</li>
<li><p>牺牲一个空间之后</p>
<ul>
<li>空：front == rear</li>
<li>满：（rear + 1）mod  maxSzie == front</li>
</ul>
</li>
<li><p>两个栈模拟队列 — FILO + LIFO == FILO</p>
<ul>
<li><p>SA，入 </p>
</li>
<li><p>SB，出 </p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">stackAnalogQueue</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">			<span class="keyword">int</span> mSize;</span><br><span class="line">        	seqStack&lt;T&gt; *SA,*SB;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;	<span class="comment">// SA、SB都空</span></span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">()</span></span>;	<span class="comment">// SA满、且SB非空。此时SA导入SB则失去队列含义</span></span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span></span>;	</span><br><span class="line">        	<span class="comment">//非满，之后SA满SB空，SA全导入到SB。SA压入新元素</span></span><br><span class="line">        	<span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T *item)</span></span>;</span><br><span class="line">        	<span class="comment">//非空.SB非空，SB直接出队；SB空，SA导入SB，再出队</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>循环队列，尾指针，便于实现队列</p>
</li>
<li><p>标签法来区分<code>front==rear</code>，空还是满</p>
<ul>
<li><p>tag  == 1，非空。tag == 0，空。</p>
</li>
<li><p>更新状态，入队转1(原来空吗)，出队转0(变成front==rear了吗)。</p>
</li>
<li><p>入队</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Q.tag==<span class="number">1</span> &amp;&amp; Q.front==Q.rear)<span class="comment">//满	</span></span><br><span class="line">    <span class="keyword">throw</span> outofRange();</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//没满</span></span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    Q.data[Q.rear] = val;</span><br><span class="line">    <span class="keyword">if</span>(q.tag == <span class="number">0</span>)	Q.tage = <span class="number">1</span>;<span class="comment">//入队更新状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Q;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>+ 出队

     <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Q.tag==<span class="number">0</span> &amp;&amp; Q.front==Q.rear)<span class="comment">//空	</span></span><br><span class="line">    <span class="keyword">throw</span> outofRange();</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//没满</span></span><br><span class="line">	Q.front = (Q.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)	</span><br><span class="line">        Q.tage = <span class="number">1</span>;<span class="comment">//出队更新状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>rear和length表示循环队列中队尾的位置和内含元素个数</p>
<ul>
<li><p>入队</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Q.length == m)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%m;</span><br><span class="line">    Q.data[Q.raer] = val;</span><br><span class="line">    Q.length++;			<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Q;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>+ 出队

     <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Q.length == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = (Q.rear-Q.length+<span class="number">1</span>+m)%m ;<span class="comment">//出队位置</span></span><br><span class="line">    Q.length--;</span><br><span class="line">	<span class="keyword">return</span> Q.data[front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>选择/归并排序</title>
    <url>/2020/07/25/%E9%80%89%E6%8B%A9-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00考点"><a href="#00考点" class="headerlink" title="00考点"></a>00考点</h3><ul>
<li>选择排序 （直接选择排序、堆排序）</li>
<li>归并排序 （二路归并）</li>
<li>上述高频</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>直接选择排序 </p>
<ul>
<li>第k趟，从 n-k+1 个记录中选择最值，和第k个元素互换<ul>
<li>在头部形成有序序列</li>
<li>选出最小值，需要k-1次比较</li>
<li>每趟形成一个最终位置</li>
</ul>
</li>
<li>总的比较次数 1 + 2 +…+（n-1)</li>
<li>不稳定 —— 大跨度元素交换</li>
<li>比较O(n^2)，同冒泡</li>
<li>交换 n-1 次</li>
</ul>
</li>
<li><p>堆排序</p>
<ul>
<li><p>堆：一棵完全二叉树，父节点，总是  大于/小于  子节点</p>
<ul>
<li>另外，编号顺序类似层次遍历</li>
<li>同一层次会聚在一块，块间有序，块内无序</li>
</ul>
</li>
<li><p>二叉堆：完全二叉树的结构，经常顺序结构实现，</p>
</li>
<li><p>直接选择排序，需要O(n)来选最值</p>
</li>
<li><p>堆排序，查找时间是O(1)，但是调整堆 —— O( log2(n) )</p>
</li>
<li><p>思想：</p>
<blockquote>
<ul>
<li>初始化序列，形成大根堆/小根堆</li>
<li>将堆顶的最值和最后一个<strong>交换</strong>，则在数组尾部形成有序序列</li>
<li>剩余记录调整成堆</li>
<li>迭代 n-1 次</li>
</ul>
</blockquote>
<ul>
<li>建立堆<ul>
<li>编号最大的非叶子结点。向上找<ul>
<li>找到不符合就和大的孩子交换，向下调整</li>
</ul>
</li>
</ul>
</li>
<li>交换最值和末尾</li>
<li>调堆<ul>
<li>和大的孩子交换</li>
</ul>
</li>
</ul>
</li>
<li><p>不稳定 —— 大跨度元素交换</p>
</li>
<li><p><strong>从小到大 —— 最大堆 / 大根堆</strong></p>
</li>
<li><p>从大到小 —— 最小堆</p>
</li>
<li><p>结点 i（从0开始存储）</p>
<ul>
<li>父节点 —— （i-1)/2</li>
<li>左孩子 2i+1</li>
<li>右孩子 2i+2</li>
</ul>
</li>
<li><p>向下调整函数 shiftdown</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftdown</span><span class="params">(T data[], <span class="keyword">int</span> pos， <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pos要被调整的结点</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    T temp = data[pos]; <span class="comment">//记录root </span></span><br><span class="line">    <span class="keyword">for</span>(;pos*<span class="number">2</span>+<span class="number">1</span> &lt; size; pos = child)&#123;</span><br><span class="line">        child = pos*<span class="number">2</span>+<span class="number">1</span>；<span class="comment">//向下</span></span><br><span class="line">        <span class="keyword">if</span>(child != size &amp;&amp; data[child+<span class="number">1</span>] &gt; data[child])<span class="comment">//选大孩子</span></span><br><span class="line">        	child++;</span><br><span class="line">        <span class="keyword">if</span>(data[child]&gt;temp)<span class="comment">//是否调整</span></span><br><span class="line">            data[pos] = data[child];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data[pos] = temp;<span class="comment">//调整root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序存储 ——  <strong>数组不要越界</strong>  </li>
</ul>
</li>
<li><p>堆排序</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(T data[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=size/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//建立堆，从最后一个非叶子结点开始向上调堆</span></span><br><span class="line">        shiftDown(data， i, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=size<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(data[<span class="number">0</span>],data[i]);</span><br><span class="line">        shiftDown(data, <span class="number">0</span>, i);		<span class="comment">// 0~i,调整成最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总的 —— O(n*log2(n))</p>
<ul>
<li>建立堆 —— O(n)；调堆 —— O(log2(n))</li>
</ul>
</li>
<li><p>快排和堆排序 —— 大量记录，找前面第某个</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>归并排序 Merging Sort<ul>
<li>归并 —— k 个有序表合并成一个新的有序表</li>
<li>k路归并</li>
<li>D&amp;M思想</li>
</ul>
</li>
<li>思想</li>
</ul>
<blockquote>
<ul>
<li>n 个记录，看做是n个长度为1的有序序列，</li>
<li>两两归并，得到  n/2“↑”  的有序序列</li>
<li>直到得到一个长度为n的</li>
</ul>
</blockquote>
<ul>
<li><p>归并</p>
<ul>
<li><p>两个指针，一个临时数组，再像归并</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T data[], T temp[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// low —— mid-1//mid —— high</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;mid &amp;&amp; j&lt;=high)</span><br><span class="line">        <span class="keyword">if</span>(data[i]&lt;data[j])</span><br><span class="line">            temp[k++] = data[i++];</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            temp[k++] = data[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;mid)</span><br><span class="line">        temp[k++] = data[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">        temp[k++] = data[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,k=low;k&lt;= high;)</span><br><span class="line">        data[k++]  = temp[i++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(T data[], T temp[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low==high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">    MergeSort(data, temp, low, mid);</span><br><span class="line">    MergeSort(data, temp, mid+<span class="number">1</span>, high);</span><br><span class="line">    Merge(data, temp, low, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>稳定的 </p>
</li>
<li><p>时间 —— O( n*log2(n) )；空间 —— O(n)</p>
</li>
</ul>
</li>
</ul>
<h3 id="03-习题"><a href="#03-习题" class="headerlink" title="03 习题"></a>03 习题</h3><ul>
<li>插入堆之后调整<ul>
<li>插入在堆尾巴上（最下层的最右边叶子）</li>
<li>和结点比较，向上调整</li>
</ul>
</li>
<li>建立堆之后调整<ul>
<li>从最后一个非叶子结点开始</li>
</ul>
</li>
<li>判断 堆<ul>
<li>画二叉树</li>
<li>根节点 大于或小于孩子</li>
</ul>
</li>
<li>起泡排序、选择排序 —— 每次一个最值到最终位置</li>
<li>插入排序 —— 一段有序，一段无序</li>
<li>二路归并 —— 相邻两个元素都应该有序</li>
<li>相比选择排序，归并排序运行效率更高，但是占空间多，代码长。</li>
<li>初态有序<ul>
<li>对冒泡，简单插入有利</li>
<li>对快速排序有害</li>
</ul>
</li>
<li>不稳定<ul>
<li>Shell、简单选择、快速排序、堆排序</li>
</ul>
</li>
<li>外排序常用归并</li>
<li>堆是完全二叉树，不是满二叉树</li>
<li>快速排序<ul>
<li>pivot</li>
<li>pivot前、后</li>
</ul>
</li>
<li>2路归并<ul>
<li>第一趟 —— 2个一组，相对有序</li>
<li>第二趟 —— 4个一组，组内有序</li>
</ul>
</li>
<li>直接插入排序和快速排序最常见</li>
<li>例子 ： 15,21,6,30,23,6,20,17<ul>
<li>直接插入排序：设队首一个元素是有序，然后遍历，不断往有序序列里插入</li>
<li>希尔排序 ： gap（5，2，1）。先隔着gap的子序列排好，最后一趟是直接插入</li>
<li>冒泡：一次一个最值到最后面。比较和交换</li>
<li>快速排序<ul>
<li>pivot每趟确定一个最终位置</li>
<li>high、low两头走，最后定pivot</li>
</ul>
</li>
<li>直接选择排序<ul>
<li>一趟选一个最值，和队头交换</li>
<li>前k-1个有序，k~n无序</li>
</ul>
</li>
<li>堆排序<ul>
<li>建立堆，调整堆</li>
<li>每次最值移到最后</li>
</ul>
</li>
<li>二路归并<ul>
<li>2,4,8,… 个一组有序</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>选择/归并</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/24/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2020/07/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="00-高频考点"><a href="#00-高频考点" class="headerlink" title="00  高频考点"></a>00  高频考点</h3><ul>
<li>线性表、顺序表的概念特点（选、填） 以及 *<em>基础算法（算法设计）(遍历、查找、插入、删除、逆置 *</em><ul>
<li>10 % 期末 —— <strong>30 %考研</strong> </li>
</ul>
</li>
</ul>
<h3 id="01-知识"><a href="#01-知识" class="headerlink" title="01 知识"></a>01 知识</h3><ul>
<li><p>线性结构 —— 排队、打印机队列(Queue)、一摞碗(Stack)</p>
<ul>
<li>第一个元素无前驱</li>
<li>最后一个无后继</li>
<li>中间，一个直接前驱，一个直接后继</li>
</ul>
</li>
<li><p>线性表Linear_list — 相同数据类型的<strong>n</strong>个数据元素序列(<strong>a0</strong>,a1,a2,a3…，<strong>a_(n-1)</strong>)</p>
<ul>
<li>首节点 a0</li>
<li>尾结点a（n-1）</li>
<li>空表</li>
<li>位序(编号 0 ~ n-1)</li>
</ul>
</li>
<li><p>线性表存储分类 —— 顺序表 + 链表</p>
<ul>
<li><p>顺序表</p>
<ul>
<li>一维数组(通常动态数组)实现，<strong>定长的</strong></li>
<li>物理位置相邻</li>
<li>表示变量<ul>
<li>data 指向线性表的指针 （基地址）</li>
<li>current_length：表长</li>
<li>Max_Size : 容量</li>
</ul>
</li>
</ul>
</li>
<li><p>顺序表操作 —— <strong>特别注意操作合法性和边界条件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化顺序表  T(n) —— S(n)</span></span><br><span class="line">maxSize = initSize;</span><br><span class="line">data = <span class="keyword">new</span> elemType[maxSize];</span><br><span class="line">currentLength = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 01 遍历 O(n) —— O(1)</span></span><br><span class="line"><span class="keyword">if</span>(currentLength == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentLength;++i)&#123;</span><br><span class="line">	visit(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 02 查找 O(n)_遍历 —— O(1)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentLength;++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(val == a[i])		<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> 				<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// -1是非法位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 03 插入 O(n) —— O(1)</span></span><br><span class="line">	<span class="comment">// i == 0 —— O(n) —— 移动n次</span></span><br><span class="line">	<span class="comment">// i == currentLength —— O(1) —— 移动 0次</span></span><br><span class="line"><span class="comment">// 平均移动 n/2  == (n + n-1 + .. + 1 +0) / (n+1)</span></span><br><span class="line"><span class="comment">// 合法边界  0~n-1 和 n</span></span><br><span class="line"><span class="comment">// 不能让线性表断开，不能失去物理位置的连续性</span></span><br><span class="line"><span class="comment">// 特别 —— 表满了的时候 —— 再申请空间</span></span><br><span class="line"><span class="keyword">if</span>(idx&lt;<span class="number">0</span> || idx &gt;currentLength) <span class="keyword">throw</span> outofRange(); <span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">if</span>(currentLength == Max_Size) resize();<span class="comment">//扩大表空间 / 或者直接报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = currentLength<span class="number">-1</span>;i&gt;idx;--i)&#123;</span><br><span class="line">    <span class="comment">// 从后面移动 idx -- currentLength-1</span></span><br><span class="line">    data[i+<span class="number">1</span>] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[idx<span class="number">-1</span>] = val;</span><br><span class="line">++currentLength; <span class="comment">// 注意更新顺序表的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 04 删除 O(n) —— O(1)</span></span><br><span class="line"><span class="comment">// 空？ // 合法位置？  0~currentLength-1  // 移动补空，保持物理位置连续 </span></span><br><span class="line"><span class="comment">// 更新currentLenght</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt; current<span class="number">-1</span>)		<span class="keyword">throw</span> outofRange()；</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=idx;i&lt;currentLength<span class="number">-1</span>;++i)&#123;</span><br><span class="line">    <span class="comment">// 不能是 = currentLength-1 </span></span><br><span class="line">    <span class="comment">//—— 相当于把currentLength位置的值传给currnet-1</span></span><br><span class="line">	data[j] == data[j+<span class="number">1</span>];</span><br><span class="line">&#125;<span class="comment">//平均移动 (n-1)/2 == (n-1 + ... + 0)/n</span></span><br><span class="line">--currentLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 05 逆置 O(n/2) O(n) —— O(1) </span></span><br><span class="line"><span class="comment">// 两头赶， 两两交换 —— 交换 n/2 次(向下取整)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;currentLength/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">	swap(data[i], data[currnetLength-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>预先分配空间</p>
<ul>
<li>逻辑顺序符合存储顺序</li>
<li>可随机读取 O(1)</li>
<li><strong>插入n/2 删除(n-1)/2</strong> 需要移动大量数据</li>
<li>适合静态的，经常进行定位的线性表</li>
</ul>
</li>
<li><p>链表 —— 值域 + 指针域 (<strong>特务单线联系</strong>)</p>
<ul>
<li><p>指针实现，变长的<strong>（用时申请，用完释放）</strong></p>
</li>
<li><p>01 单链表 逻辑相邻只能看后继</p>
</li>
<li><p>02 双链表 逻辑相邻前驱后继都可</p>
</li>
<li><p>03 循环链表 表尾指向表头节点 —— <strong>环</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="02-习题"><a href="#02-习题" class="headerlink" title="02 习题"></a>02 习题</h3><ul>
<li>顺序存储，存储密度大。链表(元素+指针)</li>
<li>顺序存储，不利于插入、删除</li>
<li>访问O(1)，插入n/2删除 (n-1)/2 —— O(n)</li>
<li><strong>合并非递减有序顺序表A、B到A——经典算法</strong><ul>
<li>高效 —— 最大限度避免移动元素</li>
<li>01 B中摘出来，插入A中。—— 不好<ul>
<li><strong>倒着遍历 —— 移动少！</strong></li>
<li>并且考虑A、B长度不同时</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n,i,j;</span><br><span class="line">m = A.length; i = m<span class="number">-1</span>;</span><br><span class="line">n = B.lenght; j = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> k = m+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(m+n &gt; A.MaxSize)	resize();</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.data[i]&gt;B.data[j])		A.data[k--] = A.data[i--];</span><br><span class="line">    <span class="keyword">else</span>					   A.data[k--] = B.data[j--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// A有余不用动 // 此处处理B有余的</span></span><br><span class="line">    A.data[k--] = B.data[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 —— O(m+n) </p>
<p>空间复杂度 —— O(1)</p>
<ul>
<li><p>删除线性表中所有职位item的数据元素。要求 O(n) —— O(1)</p>
<ul>
<li><p>01 普通顺序表删除，但是删除的最差情况O(n^2)</p>
</li>
<li><p>02 《王道》里见过的，碰到item就移动覆盖，最后更新currentLength。</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>+ 03 两个指针对着走，item被后面的覆盖。

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j=currentLength;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j &amp;&amp; data[i]!=item) 	i++; <span class="comment">// 从前面找到itme</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j &amp;&amp; data[j]==item)	j--; <span class="comment">// 从后面找到不是item</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)		</span><br><span class="line">        data[i++] = data[j--];			<span class="comment">//  前面的item被覆盖</span></span><br><span class="line">&#125;</span><br><span class="line">currentLength = i;</span><br><span class="line"><span class="comment">// 但是改变相对位置， 不稳定。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;	<span class="comment">// j 工作指针； i 看着item</span></span><br><span class="line"><span class="keyword">while</span>(j&lt;n)&#123;	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">if</span>(data[j]==item)	j++;<span class="comment">// 找到item 则不管</span></span><br><span class="line">    <span class="keyword">else</span>				data[i++] = data[j++];<span class="comment">// 不是item就移到前面, 覆盖掉i(item).</span></span><br><span class="line">&#125;</span><br><span class="line">currentLength = i; <span class="comment">// 更新信息</span></span><br><span class="line"><span class="comment">// 不改变相对位置。</span></span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>要求。(a0,a1….an)  ——&gt; (ap,…a0,ap-1)</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 巧用逆置 0~n-1，0~p-1，p~n-1</span></span><br><span class="line"><span class="comment">// O(n) —— O(1)</span></span><br><span class="line"><span class="comment">// 逆置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; ++i)&#123;		<span class="comment">// n/2</span></span><br><span class="line">	swap(data[i],data[n-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>顺序表，物理位置相邻来表示逻辑上相邻的关系。<ul>
<li>链式，通过指针/地址实现</li>
</ul>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
</search>
